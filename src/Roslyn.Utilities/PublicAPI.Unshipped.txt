Microsoft.CodeAnalysis.ArrayBuilderExtensions
Microsoft.CodeAnalysis.ArrayElement<T>
Microsoft.CodeAnalysis.ArrayElement<T>.ArrayElement() -> void
Microsoft.CodeAnalysis.ArrayElement<T>.Value -> T
Microsoft.CodeAnalysis.BitVector
Microsoft.CodeAnalysis.BitVector.Capacity.get -> int
Microsoft.CodeAnalysis.BitVector.Clear() -> void
Microsoft.CodeAnalysis.BitVector.Clone() -> Microsoft.CodeAnalysis.BitVector
Microsoft.CodeAnalysis.BitVector.EnsureCapacity(int newCapacity) -> void
Microsoft.CodeAnalysis.BitVector.Equals(Microsoft.CodeAnalysis.BitVector other) -> bool
Microsoft.CodeAnalysis.BitVector.IntersectWith(in Microsoft.CodeAnalysis.BitVector other) -> bool
Microsoft.CodeAnalysis.BitVector.IsNull.get -> bool
Microsoft.CodeAnalysis.BitVector.TrueBits() -> System.Collections.Generic.IEnumerable<int>
Microsoft.CodeAnalysis.BitVector.UnionWith(in Microsoft.CodeAnalysis.BitVector other) -> bool
Microsoft.CodeAnalysis.BitVector.Words() -> System.Collections.Generic.IEnumerable<uint>
Microsoft.CodeAnalysis.BitVector.this[int index].get -> bool
Microsoft.CodeAnalysis.BitVector.this[int index].set -> void
Microsoft.CodeAnalysis.Boxes
Microsoft.CodeAnalysis.CachingBase<TEntry>
Microsoft.CodeAnalysis.CachingFactory<TKey, TValue>
Microsoft.CodeAnalysis.CachingFactory<TKey, TValue>.Add(TKey key, TValue value) -> void
Microsoft.CodeAnalysis.CachingFactory<TKey, TValue>.CachingFactory(int size, System.Func<TKey, TValue> valueFactory, System.Func<TKey, int> keyHash, System.Func<TKey, TValue, bool> keyValueEquality) -> void
Microsoft.CodeAnalysis.CachingFactory<TKey, TValue>.Entry
Microsoft.CodeAnalysis.CachingFactory<TKey, TValue>.Entry.Entry() -> void
Microsoft.CodeAnalysis.CachingFactory<TKey, TValue>.GetOrMakeValue(TKey key) -> TValue
Microsoft.CodeAnalysis.CachingFactory<TKey, TValue>.TryGetValue(TKey key, out TValue value) -> bool
Microsoft.CodeAnalysis.CachingIdentityFactory<TKey, TValue>
Microsoft.CodeAnalysis.CachingIdentityFactory<TKey, TValue>.Add(TKey key, TValue value) -> void
Microsoft.CodeAnalysis.CachingIdentityFactory<TKey, TValue>.CachingIdentityFactory(int size, System.Func<TKey, TValue> valueFactory) -> void
Microsoft.CodeAnalysis.CachingIdentityFactory<TKey, TValue>.CachingIdentityFactory(int size, System.Func<TKey, TValue> valueFactory, Microsoft.CodeAnalysis.PooledObjects.ObjectPool<Microsoft.CodeAnalysis.CachingIdentityFactory<TKey, TValue>> pool) -> void
Microsoft.CodeAnalysis.CachingIdentityFactory<TKey, TValue>.Entry
Microsoft.CodeAnalysis.CachingIdentityFactory<TKey, TValue>.Entry.Entry() -> void
Microsoft.CodeAnalysis.CachingIdentityFactory<TKey, TValue>.Free() -> void
Microsoft.CodeAnalysis.CachingIdentityFactory<TKey, TValue>.GetOrMakeValue(TKey key) -> TValue
Microsoft.CodeAnalysis.CachingIdentityFactory<TKey, TValue>.TryGetValue(TKey key, out TValue value) -> bool
Microsoft.CodeAnalysis.CaseInsensitiveComparison
Microsoft.CodeAnalysis.Collections.ByteSequenceComparer
Microsoft.CodeAnalysis.Collections.CachingDictionary<TKey, TElement>
Microsoft.CodeAnalysis.Collections.CachingDictionary<TKey, TElement>.AddValues(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<TElement> array) -> void
Microsoft.CodeAnalysis.Collections.CachingDictionary<TKey, TElement>.CachingDictionary(System.Func<TKey, System.Collections.Immutable.ImmutableArray<TElement>> getElementsOfKey, System.Func<System.Collections.Generic.IEqualityComparer<TKey>, System.Collections.Generic.HashSet<TKey>> getKeys, System.Collections.Generic.IEqualityComparer<TKey> comparer) -> void
Microsoft.CodeAnalysis.Collections.CachingDictionary<TKey, TElement>.Contains(TKey key) -> bool
Microsoft.CodeAnalysis.Collections.CachingDictionary<TKey, TElement>.Count.get -> int
Microsoft.CodeAnalysis.Collections.CachingDictionary<TKey, TElement>.Keys.get -> System.Collections.Generic.IEnumerable<TKey>
Microsoft.CodeAnalysis.Collections.CachingDictionary<TKey, TElement>.this[TKey key].get -> System.Collections.Immutable.ImmutableArray<TElement>
Microsoft.CodeAnalysis.Collections.ImmutableMemoryStream
Microsoft.CodeAnalysis.Collections.ImmutableMemoryStream.GetBuffer() -> System.Collections.Immutable.ImmutableArray<byte>
Microsoft.CodeAnalysis.Collections.KeyedStack<T, R>
Microsoft.CodeAnalysis.Collections.KeyedStack<T, R>.KeyedStack() -> void
Microsoft.CodeAnalysis.Collections.KeyedStack<T, R>.Push(T key, R value) -> void
Microsoft.CodeAnalysis.Collections.KeyedStack<T, R>.TryPop(T key, out R value) -> bool
Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>
Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.Add(K k, V v) -> void
Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.Contains(K key, V value) -> bool
Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.Free() -> void
Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.GetEnumerator() -> System.Collections.Generic.Dictionary<K, Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.ValueSet>.Enumerator
Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.IsEmpty.get -> bool
Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.Keys.get -> System.Collections.Generic.Dictionary<K, Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.ValueSet>.KeyCollection
Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.OrderPreservingMultiDictionary() -> void
Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.ValueSet
Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.ValueSet.Contains(V item) -> bool
Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.ValueSet.Enumerator
Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.ValueSet.Enumerator.Current.get -> V
Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.ValueSet.Enumerator.Dispose() -> void
Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.ValueSet.Enumerator.Enumerator(Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.ValueSet valueSet) -> void
Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.ValueSet.Enumerator.MoveNext() -> bool
Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.ValueSet.Enumerator.Reset() -> void
Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.ValueSet.Free() -> void
Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.ValueSet.GetEnumerator() -> Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.ValueSet.Enumerator
Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.ValueSet.WithAddedItem(V item) -> Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.ValueSet
Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.this[K k].get -> System.Collections.Immutable.ImmutableArray<V>
Microsoft.CodeAnalysis.Collections.OrderedSet<T>
Microsoft.CodeAnalysis.Collections.OrderedSet<T>.Add(T item) -> bool
Microsoft.CodeAnalysis.Collections.OrderedSet<T>.AddRange(System.Collections.Generic.IEnumerable<T> items) -> void
Microsoft.CodeAnalysis.Collections.OrderedSet<T>.Clear() -> void
Microsoft.CodeAnalysis.Collections.OrderedSet<T>.Contains(T item) -> bool
Microsoft.CodeAnalysis.Collections.OrderedSet<T>.Count.get -> int
Microsoft.CodeAnalysis.Collections.OrderedSet<T>.GetEnumerator() -> System.Collections.Generic.IEnumerator<T>
Microsoft.CodeAnalysis.Collections.OrderedSet<T>.OrderedSet() -> void
Microsoft.CodeAnalysis.Collections.OrderedSet<T>.OrderedSet(System.Collections.Generic.IEnumerable<T> items) -> void
Microsoft.CodeAnalysis.Collections.SmallConcurrentSetOfInts
Microsoft.CodeAnalysis.Collections.SmallConcurrentSetOfInts.Add(int i) -> bool
Microsoft.CodeAnalysis.Collections.SmallConcurrentSetOfInts.Contains(int i) -> bool
Microsoft.CodeAnalysis.Collections.SmallConcurrentSetOfInts.SmallConcurrentSetOfInts() -> void
Microsoft.CodeAnalysis.CommonDiagnosticComparer
Microsoft.CodeAnalysis.CommonDiagnosticComparer.Equals(Microsoft.CodeAnalysis.Diagnostic x, Microsoft.CodeAnalysis.Diagnostic y) -> bool
Microsoft.CodeAnalysis.CommonDiagnosticComparer.GetHashCode(Microsoft.CodeAnalysis.Diagnostic obj) -> int
Microsoft.CodeAnalysis.CommonMessageProvider
Microsoft.CodeAnalysis.CommonMessageProvider.CommonMessageProvider() -> void
Microsoft.CodeAnalysis.CommonMessageProvider.CreateDiagnostic(int code, Microsoft.CodeAnalysis.Location location) -> Microsoft.CodeAnalysis.Diagnostic
Microsoft.CodeAnalysis.CommonMessageProvider.GetIdForErrorCode(int errorCode) -> string
Microsoft.CodeAnalysis.ConcurrentCache<TKey, TValue>
Microsoft.CodeAnalysis.ConcurrentCache<TKey, TValue>.ConcurrentCache(int size) -> void
Microsoft.CodeAnalysis.ConcurrentCache<TKey, TValue>.Entry
Microsoft.CodeAnalysis.ConcurrentCache<TKey, TValue>.TryAdd(TKey key, TValue value) -> bool
Microsoft.CodeAnalysis.ConcurrentCache<TKey, TValue>.TryGetValue(TKey key, out TValue value) -> bool
Microsoft.CodeAnalysis.ConsListExtensions
Microsoft.CodeAnalysis.Diagnostic
Microsoft.CodeAnalysis.Diagnostic.Diagnostic() -> void
Microsoft.CodeAnalysis.Diagnostic.IsWarningAsError.get -> bool
Microsoft.CodeAnalysis.Diagnostic.SimpleDiagnostic
Microsoft.CodeAnalysis.Diagnostic.WithReportDiagnostic(Microsoft.CodeAnalysis.ReportDiagnostic reportAction) -> Microsoft.CodeAnalysis.Diagnostic
Microsoft.CodeAnalysis.DiagnosticBag
Microsoft.CodeAnalysis.DiagnosticBag.Add(Microsoft.CodeAnalysis.Diagnostic diag) -> void
Microsoft.CodeAnalysis.DiagnosticBag.AddRange(Microsoft.CodeAnalysis.DiagnosticBag bag) -> void
Microsoft.CodeAnalysis.DiagnosticBag.AddRange(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> diagnostics) -> void
Microsoft.CodeAnalysis.DiagnosticBag.AddRange<T>(System.Collections.Immutable.ImmutableArray<T> diagnostics) -> void
Microsoft.CodeAnalysis.DiagnosticBag.AddRangeAndFree(Microsoft.CodeAnalysis.DiagnosticBag bag) -> void
Microsoft.CodeAnalysis.DiagnosticBag.AsEnumerable() -> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic>
Microsoft.CodeAnalysis.DiagnosticBag.AsEnumerableWithoutResolution() -> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic>
Microsoft.CodeAnalysis.DiagnosticBag.Clear() -> void
Microsoft.CodeAnalysis.DiagnosticBag.DebuggerProxy
Microsoft.CodeAnalysis.DiagnosticBag.DebuggerProxy.DebuggerProxy(Microsoft.CodeAnalysis.DiagnosticBag bag) -> void
Microsoft.CodeAnalysis.DiagnosticBag.DebuggerProxy.Diagnostics.get -> object[]
Microsoft.CodeAnalysis.DiagnosticBag.DiagnosticBag() -> void
Microsoft.CodeAnalysis.DiagnosticBag.Free() -> void
Microsoft.CodeAnalysis.DiagnosticBag.HasAnyErrors() -> bool
Microsoft.CodeAnalysis.DiagnosticBag.HasAnyResolvedErrors() -> bool
Microsoft.CodeAnalysis.DiagnosticBag.IsEmptyWithoutResolution.get -> bool
Microsoft.CodeAnalysis.DiagnosticBag.ToReadOnly() -> System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic>
Microsoft.CodeAnalysis.DiagnosticBag.ToReadOnly<TDiagnostic>() -> System.Collections.Immutable.ImmutableArray<TDiagnostic>
Microsoft.CodeAnalysis.DiagnosticBag.ToReadOnlyAndFree() -> System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic>
Microsoft.CodeAnalysis.DiagnosticBag.ToReadOnlyAndFree<TDiagnostic>() -> System.Collections.Immutable.ImmutableArray<TDiagnostic>
Microsoft.CodeAnalysis.DiagnosticDescriptor
Microsoft.CodeAnalysis.DiagnosticDescriptor.Category.get -> string
Microsoft.CodeAnalysis.DiagnosticDescriptor.CustomTags.get -> System.Collections.Generic.IEnumerable<string>
Microsoft.CodeAnalysis.DiagnosticDescriptor.DefaultSeverity.get -> Microsoft.CodeAnalysis.DiagnosticSeverity
Microsoft.CodeAnalysis.DiagnosticDescriptor.Description.get -> Microsoft.CodeAnalysis.LocalizableString
Microsoft.CodeAnalysis.DiagnosticDescriptor.DiagnosticDescriptor(string id, Microsoft.CodeAnalysis.LocalizableString title, Microsoft.CodeAnalysis.LocalizableString messageFormat, string category, Microsoft.CodeAnalysis.DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, Microsoft.CodeAnalysis.LocalizableString description = null, string helpLinkUri = null, params string[] customTags) -> void
Microsoft.CodeAnalysis.DiagnosticDescriptor.DiagnosticDescriptor(string id, string title, string messageFormat, string category, Microsoft.CodeAnalysis.DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, string description = null, string helpLinkUri = null, params string[] customTags) -> void
Microsoft.CodeAnalysis.DiagnosticDescriptor.Equals(Microsoft.CodeAnalysis.DiagnosticDescriptor other) -> bool
Microsoft.CodeAnalysis.DiagnosticDescriptor.HelpLinkUri.get -> string
Microsoft.CodeAnalysis.DiagnosticDescriptor.Id.get -> string
Microsoft.CodeAnalysis.DiagnosticDescriptor.IsEnabledByDefault.get -> bool
Microsoft.CodeAnalysis.DiagnosticDescriptor.MessageFormat.get -> Microsoft.CodeAnalysis.LocalizableString
Microsoft.CodeAnalysis.DiagnosticDescriptor.Title.get -> Microsoft.CodeAnalysis.LocalizableString
Microsoft.CodeAnalysis.DiagnosticFormatter
Microsoft.CodeAnalysis.DiagnosticFormatter.DiagnosticFormatter() -> void
Microsoft.CodeAnalysis.DiagnosticFormatter.GetMessagePrefix(Microsoft.CodeAnalysis.Diagnostic diagnostic) -> string
Microsoft.CodeAnalysis.DiagnosticInfo
Microsoft.CodeAnalysis.DiagnosticInfo.Category.get -> string
Microsoft.CodeAnalysis.DiagnosticInfo.Code.get -> int
Microsoft.CodeAnalysis.DiagnosticInfo.DefaultSeverity.get -> Microsoft.CodeAnalysis.DiagnosticSeverity
Microsoft.CodeAnalysis.DiagnosticInfo.Descriptor.get -> Microsoft.CodeAnalysis.DiagnosticDescriptor
Microsoft.CodeAnalysis.DiagnosticInfo.DiagnosticInfo(Roslyn.Utilities.ObjectReader reader) -> void
Microsoft.CodeAnalysis.DiagnosticInfo.GetArgumentsToUse(System.IFormatProvider formatProvider) -> object[]
Microsoft.CodeAnalysis.DiagnosticInfo.GetInstanceWithSeverity(Microsoft.CodeAnalysis.DiagnosticSeverity severity) -> Microsoft.CodeAnalysis.DiagnosticInfo
Microsoft.CodeAnalysis.DiagnosticInfo.IsNotConfigurable() -> bool
Microsoft.CodeAnalysis.DiagnosticInfo.IsWarningAsError.get -> bool
Microsoft.CodeAnalysis.DiagnosticInfo.MessageIdentifier.get -> string
Microsoft.CodeAnalysis.DiagnosticInfo.Severity.get -> Microsoft.CodeAnalysis.DiagnosticSeverity
Microsoft.CodeAnalysis.DiagnosticInfo.ToString(System.IFormatProvider formatProvider) -> string
Microsoft.CodeAnalysis.DiagnosticInfo.WarningLevel.get -> int
Microsoft.CodeAnalysis.DiagnosticSeverity
Microsoft.CodeAnalysis.DiagnosticSeverity.Error = 3 -> Microsoft.CodeAnalysis.DiagnosticSeverity
Microsoft.CodeAnalysis.DiagnosticSeverity.Hidden = 0 -> Microsoft.CodeAnalysis.DiagnosticSeverity
Microsoft.CodeAnalysis.DiagnosticSeverity.Info = 1 -> Microsoft.CodeAnalysis.DiagnosticSeverity
Microsoft.CodeAnalysis.DiagnosticSeverity.Warning = 2 -> Microsoft.CodeAnalysis.DiagnosticSeverity
Microsoft.CodeAnalysis.DiagnosticWithInfo
Microsoft.CodeAnalysis.DiagnosticWithInfo.DiagnosticWithInfo(Microsoft.CodeAnalysis.DiagnosticInfo info, Microsoft.CodeAnalysis.Location location, bool isSuppressed = false) -> void
Microsoft.CodeAnalysis.DiagnosticWithInfo.Info.get -> Microsoft.CodeAnalysis.DiagnosticInfo
Microsoft.CodeAnalysis.Diagnostics.SuppressionInfo
Microsoft.CodeAnalysis.Diagnostics.SuppressionInfo.Id.get -> string
Microsoft.CodeAnalysis.Diagnostics.SuppressionInfo.SuppressionInfo() -> void
Microsoft.CodeAnalysis.EmbeddedText
Microsoft.CodeAnalysis.EmbeddedText.Checksum.get -> System.Collections.Immutable.ImmutableArray<byte>
Microsoft.CodeAnalysis.EmbeddedText.ChecksumAlgorithm.get -> Microsoft.CodeAnalysis.Text.SourceHashAlgorithm
Microsoft.CodeAnalysis.EmbeddedText.FilePath.get -> string
Microsoft.CodeAnalysis.EnumerableExtensions
Microsoft.CodeAnalysis.ExternalFileLocation
Microsoft.CodeAnalysis.ExternalFileLocation.Equals(Microsoft.CodeAnalysis.ExternalFileLocation obj) -> bool
Microsoft.CodeAnalysis.FailFast
Microsoft.CodeAnalysis.FatalError
Microsoft.CodeAnalysis.FileLinePositionSpan
Microsoft.CodeAnalysis.FileLinePositionSpan.EndLinePosition.get -> Microsoft.CodeAnalysis.Text.LinePosition
Microsoft.CodeAnalysis.FileLinePositionSpan.Equals(Microsoft.CodeAnalysis.FileLinePositionSpan other) -> bool
Microsoft.CodeAnalysis.FileLinePositionSpan.FileLinePositionSpan(string path, Microsoft.CodeAnalysis.Text.LinePosition start, Microsoft.CodeAnalysis.Text.LinePosition end) -> void
Microsoft.CodeAnalysis.FileLinePositionSpan.FileLinePositionSpan(string path, Microsoft.CodeAnalysis.Text.LinePositionSpan span) -> void
Microsoft.CodeAnalysis.FileLinePositionSpan.HasMappedPath.get -> bool
Microsoft.CodeAnalysis.FileLinePositionSpan.IsValid.get -> bool
Microsoft.CodeAnalysis.FileLinePositionSpan.Path.get -> string
Microsoft.CodeAnalysis.FileLinePositionSpan.Span.get -> Microsoft.CodeAnalysis.Text.LinePositionSpan
Microsoft.CodeAnalysis.FileLinePositionSpan.StartLinePosition.get -> Microsoft.CodeAnalysis.Text.LinePosition
Microsoft.CodeAnalysis.Grouping<TKey, TElement>
Microsoft.CodeAnalysis.Grouping<TKey, TElement>.GetEnumerator() -> System.Collections.Generic.IEnumerator<TElement>
Microsoft.CodeAnalysis.Grouping<TKey, TElement>.Grouping(System.Collections.Generic.KeyValuePair<TKey, System.Collections.Generic.IEnumerable<TElement>> pair) -> void
Microsoft.CodeAnalysis.Grouping<TKey, TElement>.Grouping(TKey key, System.Collections.Generic.IEnumerable<TElement> elements) -> void
Microsoft.CodeAnalysis.Grouping<TKey, TElement>.Key.get -> TKey
Microsoft.CodeAnalysis.HashSetExtensions
Microsoft.CodeAnalysis.IdentifierCollection
Microsoft.CodeAnalysis.IdentifierCollection.AddIdentifier(string identifier) -> void
Microsoft.CodeAnalysis.IdentifierCollection.AddIdentifiers(System.Collections.Generic.IEnumerable<string> identifiers) -> void
Microsoft.CodeAnalysis.IdentifierCollection.AsCaseInsensitiveCollection() -> System.Collections.Generic.ICollection<string>
Microsoft.CodeAnalysis.IdentifierCollection.AsCaseSensitiveCollection() -> System.Collections.Generic.ICollection<string>
Microsoft.CodeAnalysis.IdentifierCollection.ContainsIdentifier(string identifier, bool caseSensitive) -> bool
Microsoft.CodeAnalysis.IdentifierCollection.IdentifierCollection() -> void
Microsoft.CodeAnalysis.IdentifierCollection.IdentifierCollection(System.Collections.Generic.IEnumerable<string> identifiers) -> void
Microsoft.CodeAnalysis.ImmutableArrayExtensions
Microsoft.CodeAnalysis.InternalDiagnosticSeverity
Microsoft.CodeAnalysis.InternalErrorCode
Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache<K, V>
Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache<K, V>.Add(K key, V value) -> void
Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache<K, V>.ConcurrentLruCache(System.Collections.Generic.KeyValuePair<K, V>[] array) -> void
Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache<K, V>.ConcurrentLruCache(int capacity) -> void
Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache<K, V>.GetOrAdd(K key, System.Func<V> creator) -> V
Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache<K, V>.GetOrAdd(K key, V value) -> V
Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache<K, V>.GetOrAdd<T>(K key, T arg, System.Func<T, V> creator) -> V
Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache<K, V>.TryGetValue(K key, out V value) -> bool
Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache<K, V>.UnsafeTryGetValue(K key, out V value) -> bool
Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache<K, V>.this[K key].get -> V
Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache<K, V>.this[K key].set -> void
Microsoft.CodeAnalysis.LocalizableResourceString
Microsoft.CodeAnalysis.LocalizableResourceString.LocalizableResourceString(string nameOfLocalizableResource, System.Resources.ResourceManager resourceManager, System.Type resourceSource) -> void
Microsoft.CodeAnalysis.LocalizableResourceString.LocalizableResourceString(string nameOfLocalizableResource, System.Resources.ResourceManager resourceManager, System.Type resourceSource, params string[] formatArguments) -> void
Microsoft.CodeAnalysis.LocalizableString
Microsoft.CodeAnalysis.LocalizableString.Equals(Microsoft.CodeAnalysis.LocalizableString other) -> bool
Microsoft.CodeAnalysis.LocalizableString.LocalizableString() -> void
Microsoft.CodeAnalysis.LocalizableString.OnException -> System.EventHandler<System.Exception>
Microsoft.CodeAnalysis.LocalizableString.ToString(System.IFormatProvider formatProvider) -> string
Microsoft.CodeAnalysis.Location
Microsoft.CodeAnalysis.NoLocation
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.Add(T item) -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.AddMany(T item, int count) -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.AddRange(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T> items) -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.AddRange(System.Collections.Generic.IEnumerable<T> items) -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.AddRange(System.Collections.Immutable.ImmutableArray<T> items) -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.AddRange(System.Collections.Immutable.ImmutableArray<T> items, int length) -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.AddRange(T[] items, int length) -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.AddRange(T[] items, int start, int length) -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.AddRange(params T[] items) -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.AddRange<S>(System.Collections.Immutable.ImmutableArray<S> items) -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.AddRange<U>(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<U> items) -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.Any() -> bool
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.ArrayBuilder() -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.ArrayBuilder(int size) -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.Clear() -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.Clip(int limit) -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.Contains(T item) -> bool
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.CopyTo(T[] array, int start) -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.Count.get -> int
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.Count.set -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.EnsureCapacity(int capacity) -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.Enumerator
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.Enumerator.Current.get -> T
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.Enumerator.Dispose() -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.Enumerator.Enumerator(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T> builder) -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.Enumerator.MoveNext() -> bool
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.Enumerator.Reset() -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.FindIndex(System.Predicate<T> match) -> int
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.FindIndex(int startIndex, System.Predicate<T> match) -> int
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.FindIndex(int startIndex, int count, System.Predicate<T> match) -> int
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.First() -> T
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.Free() -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.GetEnumerator() -> Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.Enumerator
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.IndexOf(T item) -> int
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.IndexOf(T item, System.Collections.Generic.IEqualityComparer<T> equalityComparer) -> int
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.IndexOf(T item, int startIndex, int count) -> int
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.Insert(int index, T item) -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.Last() -> T
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.RemoveAt(int index) -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.RemoveDuplicates() -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.RemoveLast() -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.ReverseContents() -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.SelectDistinct<S>(System.Func<T, S> selector) -> System.Collections.Immutable.ImmutableArray<S>
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.SetItem(int index, T value) -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.Sort() -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.Sort(System.Collections.Generic.IComparer<T> comparer) -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.Sort(System.Comparison<T> compare) -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.Sort(int startIndex, System.Collections.Generic.IComparer<T> comparer) -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.ToArray() -> T[]
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.ToArrayAndFree() -> T[]
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.ToDictionary<K>(System.Func<T, K> keySelector, System.Collections.Generic.IEqualityComparer<K> comparer = null) -> System.Collections.Generic.Dictionary<K, System.Collections.Immutable.ImmutableArray<T>>
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.ToDowncastedImmutable<U>() -> System.Collections.Immutable.ImmutableArray<U>
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.ToImmutable() -> System.Collections.Immutable.ImmutableArray<T>
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.ToImmutableAndFree() -> System.Collections.Immutable.ImmutableArray<T>
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.ToImmutableOrNull() -> System.Collections.Immutable.ImmutableArray<T>
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.ZeroInit(int count) -> void
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.this[int index].get -> T
Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.this[int index].set -> void
Microsoft.CodeAnalysis.PooledObjects.ObjectPool<T>
Microsoft.CodeAnalysis.PooledObjects.ObjectPool<T>.Allocate() -> T
Microsoft.CodeAnalysis.PooledObjects.ObjectPool<T>.Factory
Microsoft.CodeAnalysis.PooledObjects.ObjectPool<T>.ForgetTrackedObject(T old, T replacement = null) -> void
Microsoft.CodeAnalysis.PooledObjects.ObjectPool<T>.Free(T obj) -> void
Microsoft.CodeAnalysis.PooledObjects.ObjectPool<T>.ObjectPool(Microsoft.CodeAnalysis.PooledObjects.ObjectPool<T>.Factory factory) -> void
Microsoft.CodeAnalysis.PooledObjects.ObjectPool<T>.ObjectPool(Microsoft.CodeAnalysis.PooledObjects.ObjectPool<T>.Factory factory, int size) -> void
Microsoft.CodeAnalysis.PooledObjects.PooledDictionary<K, V>
Microsoft.CodeAnalysis.PooledObjects.PooledDictionary<K, V>.Free() -> void
Microsoft.CodeAnalysis.PooledObjects.PooledDictionary<K, V>.ToImmutableDictionaryAndFree() -> System.Collections.Immutable.ImmutableDictionary<K, V>
Microsoft.CodeAnalysis.PooledObjects.PooledHashSet<T>
Microsoft.CodeAnalysis.PooledObjects.PooledHashSet<T>.Free() -> void
Microsoft.CodeAnalysis.PooledObjects.PooledStopwatch
Microsoft.CodeAnalysis.PooledObjects.PooledStopwatch.Free() -> void
Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder
Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder.Free() -> void
Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder.Length.get -> int
Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder.ToString() -> string
Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder.ToStringAndFree() -> string
Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder.ToStringAndFree(int startIndex, int length) -> string
Microsoft.CodeAnalysis.ReadOnlyUnmanagedMemoryStream
Microsoft.CodeAnalysis.ReadOnlyUnmanagedMemoryStream.ReadOnlyUnmanagedMemoryStream(object memoryOwner, System.IntPtr data, int length) -> void
Microsoft.CodeAnalysis.RelativePathResolver
Microsoft.CodeAnalysis.RelativePathResolver.BaseDirectory.get -> string
Microsoft.CodeAnalysis.RelativePathResolver.Equals(Microsoft.CodeAnalysis.RelativePathResolver other) -> bool
Microsoft.CodeAnalysis.RelativePathResolver.RelativePathResolver(System.Collections.Immutable.ImmutableArray<string> searchPaths, string baseDirectory) -> void
Microsoft.CodeAnalysis.RelativePathResolver.ResolvePath(string reference, string baseFilePath) -> string
Microsoft.CodeAnalysis.RelativePathResolver.SearchPaths.get -> System.Collections.Immutable.ImmutableArray<string>
Microsoft.CodeAnalysis.RelativePathResolver.WithBaseDirectory(string baseDirectory) -> Microsoft.CodeAnalysis.RelativePathResolver
Microsoft.CodeAnalysis.RelativePathResolver.WithSearchPaths(System.Collections.Immutable.ImmutableArray<string> searchPaths) -> Microsoft.CodeAnalysis.RelativePathResolver
Microsoft.CodeAnalysis.ReportDiagnostic
Microsoft.CodeAnalysis.ReportDiagnostic.Default = 0 -> Microsoft.CodeAnalysis.ReportDiagnostic
Microsoft.CodeAnalysis.ReportDiagnostic.Error = 1 -> Microsoft.CodeAnalysis.ReportDiagnostic
Microsoft.CodeAnalysis.ReportDiagnostic.Hidden = 4 -> Microsoft.CodeAnalysis.ReportDiagnostic
Microsoft.CodeAnalysis.ReportDiagnostic.Info = 3 -> Microsoft.CodeAnalysis.ReportDiagnostic
Microsoft.CodeAnalysis.ReportDiagnostic.Suppress = 5 -> Microsoft.CodeAnalysis.ReportDiagnostic
Microsoft.CodeAnalysis.ReportDiagnostic.Warn = 2 -> Microsoft.CodeAnalysis.ReportDiagnostic
Microsoft.CodeAnalysis.RequiredLanguageVersion
Microsoft.CodeAnalysis.RequiredLanguageVersion.RequiredLanguageVersion() -> void
Microsoft.CodeAnalysis.SmallDictionary<K, V>
Microsoft.CodeAnalysis.SmallDictionary<K, V>.Add(K key, V value) -> void
Microsoft.CodeAnalysis.SmallDictionary<K, V>.AssertBalanced() -> void
Microsoft.CodeAnalysis.SmallDictionary<K, V>.ContainsKey(K key) -> bool
Microsoft.CodeAnalysis.SmallDictionary<K, V>.EnumerableImpl
Microsoft.CodeAnalysis.SmallDictionary<K, V>.EnumerableImpl.EnumerableImpl(Microsoft.CodeAnalysis.SmallDictionary<K, V>.Enumerator e) -> void
Microsoft.CodeAnalysis.SmallDictionary<K, V>.Enumerator
Microsoft.CodeAnalysis.SmallDictionary<K, V>.Enumerator.Current.get -> System.Collections.Generic.KeyValuePair<K, V>
Microsoft.CodeAnalysis.SmallDictionary<K, V>.Enumerator.Enumerator(Microsoft.CodeAnalysis.SmallDictionary<K, V> dict) -> void
Microsoft.CodeAnalysis.SmallDictionary<K, V>.Enumerator.MoveNext() -> bool
Microsoft.CodeAnalysis.SmallDictionary<K, V>.GetEnumerator() -> Microsoft.CodeAnalysis.SmallDictionary<K, V>.Enumerator
Microsoft.CodeAnalysis.SmallDictionary<K, V>.KeyCollection
Microsoft.CodeAnalysis.SmallDictionary<K, V>.KeyCollection.EnumerableImpl
Microsoft.CodeAnalysis.SmallDictionary<K, V>.KeyCollection.EnumerableImpl.EnumerableImpl(Microsoft.CodeAnalysis.SmallDictionary<K, V>.KeyCollection.Enumerator e) -> void
Microsoft.CodeAnalysis.SmallDictionary<K, V>.KeyCollection.Enumerator
Microsoft.CodeAnalysis.SmallDictionary<K, V>.KeyCollection.Enumerator.Current.get -> K
Microsoft.CodeAnalysis.SmallDictionary<K, V>.KeyCollection.Enumerator.Enumerator(Microsoft.CodeAnalysis.SmallDictionary<K, V> dict) -> void
Microsoft.CodeAnalysis.SmallDictionary<K, V>.KeyCollection.Enumerator.MoveNext() -> bool
Microsoft.CodeAnalysis.SmallDictionary<K, V>.KeyCollection.GetEnumerator() -> Microsoft.CodeAnalysis.SmallDictionary<K, V>.KeyCollection.Enumerator
Microsoft.CodeAnalysis.SmallDictionary<K, V>.KeyCollection.KeyCollection(Microsoft.CodeAnalysis.SmallDictionary<K, V> dict) -> void
Microsoft.CodeAnalysis.SmallDictionary<K, V>.Keys.get -> Microsoft.CodeAnalysis.SmallDictionary<K, V>.KeyCollection
Microsoft.CodeAnalysis.SmallDictionary<K, V>.SmallDictionary() -> void
Microsoft.CodeAnalysis.SmallDictionary<K, V>.SmallDictionary(Microsoft.CodeAnalysis.SmallDictionary<K, V> other, System.Collections.Generic.IEqualityComparer<K> comparer) -> void
Microsoft.CodeAnalysis.SmallDictionary<K, V>.SmallDictionary(System.Collections.Generic.IEqualityComparer<K> comparer) -> void
Microsoft.CodeAnalysis.SmallDictionary<K, V>.TryGetValue(K key, out V value) -> bool
Microsoft.CodeAnalysis.SmallDictionary<K, V>.ValueCollection
Microsoft.CodeAnalysis.SmallDictionary<K, V>.ValueCollection.EnumerableImpl
Microsoft.CodeAnalysis.SmallDictionary<K, V>.ValueCollection.EnumerableImpl.EnumerableImpl(Microsoft.CodeAnalysis.SmallDictionary<K, V>.ValueCollection.Enumerator e) -> void
Microsoft.CodeAnalysis.SmallDictionary<K, V>.ValueCollection.Enumerator
Microsoft.CodeAnalysis.SmallDictionary<K, V>.ValueCollection.Enumerator.Current.get -> V
Microsoft.CodeAnalysis.SmallDictionary<K, V>.ValueCollection.Enumerator.Enumerator(Microsoft.CodeAnalysis.SmallDictionary<K, V> dict) -> void
Microsoft.CodeAnalysis.SmallDictionary<K, V>.ValueCollection.Enumerator.MoveNext() -> bool
Microsoft.CodeAnalysis.SmallDictionary<K, V>.ValueCollection.GetEnumerator() -> Microsoft.CodeAnalysis.SmallDictionary<K, V>.ValueCollection.Enumerator
Microsoft.CodeAnalysis.SmallDictionary<K, V>.ValueCollection.ValueCollection(Microsoft.CodeAnalysis.SmallDictionary<K, V> dict) -> void
Microsoft.CodeAnalysis.SmallDictionary<K, V>.Values.get -> Microsoft.CodeAnalysis.SmallDictionary<K, V>.ValueCollection
Microsoft.CodeAnalysis.SmallDictionary<K, V>.this[K key].get -> V
Microsoft.CodeAnalysis.SmallDictionary<K, V>.this[K key].set -> void
Microsoft.CodeAnalysis.StackGuard
Microsoft.CodeAnalysis.StaticCast<T>
Microsoft.CodeAnalysis.Text.ChangedText
Microsoft.CodeAnalysis.Text.ChangedText.ChangedText(Microsoft.CodeAnalysis.Text.SourceText oldText, Microsoft.CodeAnalysis.Text.SourceText newText, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Text.TextChangeRange> changeRanges) -> void
Microsoft.CodeAnalysis.Text.ChangedText.Changes.get -> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Text.TextChangeRange>
Microsoft.CodeAnalysis.Text.CompositeText
Microsoft.CodeAnalysis.Text.LargeText
Microsoft.CodeAnalysis.Text.LargeTextWriter
Microsoft.CodeAnalysis.Text.LargeTextWriter.AppendChunk(char[] chunk) -> void
Microsoft.CodeAnalysis.Text.LargeTextWriter.CanFitInAllocatedBuffer(int chars) -> bool
Microsoft.CodeAnalysis.Text.LargeTextWriter.LargeTextWriter(System.Text.Encoding encoding, Microsoft.CodeAnalysis.Text.SourceHashAlgorithm checksumAlgorithm, int length) -> void
Microsoft.CodeAnalysis.Text.LinePosition
Microsoft.CodeAnalysis.Text.LinePosition.Character.get -> int
Microsoft.CodeAnalysis.Text.LinePosition.CompareTo(Microsoft.CodeAnalysis.Text.LinePosition other) -> int
Microsoft.CodeAnalysis.Text.LinePosition.Equals(Microsoft.CodeAnalysis.Text.LinePosition other) -> bool
Microsoft.CodeAnalysis.Text.LinePosition.Line.get -> int
Microsoft.CodeAnalysis.Text.LinePosition.LinePosition(int character) -> void
Microsoft.CodeAnalysis.Text.LinePosition.LinePosition(int line, int character) -> void
Microsoft.CodeAnalysis.Text.LinePositionSpan
Microsoft.CodeAnalysis.Text.LinePositionSpan.End.get -> Microsoft.CodeAnalysis.Text.LinePosition
Microsoft.CodeAnalysis.Text.LinePositionSpan.Equals(Microsoft.CodeAnalysis.Text.LinePositionSpan other) -> bool
Microsoft.CodeAnalysis.Text.LinePositionSpan.LinePositionSpan(Microsoft.CodeAnalysis.Text.LinePosition start, Microsoft.CodeAnalysis.Text.LinePosition end) -> void
Microsoft.CodeAnalysis.Text.LinePositionSpan.Start.get -> Microsoft.CodeAnalysis.Text.LinePosition
Microsoft.CodeAnalysis.Text.SlidingTextWindow
Microsoft.CodeAnalysis.Text.SlidingTextWindow.AdvanceChar() -> void
Microsoft.CodeAnalysis.Text.SlidingTextWindow.AdvanceChar(int n) -> void
Microsoft.CodeAnalysis.Text.SlidingTextWindow.AdvanceIfMatches(string desired) -> bool
Microsoft.CodeAnalysis.Text.SlidingTextWindow.CharacterWindow.get -> char[]
Microsoft.CodeAnalysis.Text.SlidingTextWindow.CharacterWindowCount.get -> int
Microsoft.CodeAnalysis.Text.SlidingTextWindow.Dispose() -> void
Microsoft.CodeAnalysis.Text.SlidingTextWindow.GetInternedText() -> string
Microsoft.CodeAnalysis.Text.SlidingTextWindow.GetText(bool intern) -> string
Microsoft.CodeAnalysis.Text.SlidingTextWindow.GetText(int position, int length, bool intern) -> string
Microsoft.CodeAnalysis.Text.SlidingTextWindow.Intern(System.Text.StringBuilder text) -> string
Microsoft.CodeAnalysis.Text.SlidingTextWindow.Intern(char[] array, int start, int length) -> string
Microsoft.CodeAnalysis.Text.SlidingTextWindow.IsReallyAtEnd() -> bool
Microsoft.CodeAnalysis.Text.SlidingTextWindow.IsUnicodeEscape() -> bool
Microsoft.CodeAnalysis.Text.SlidingTextWindow.LexemeRelativeStart.get -> int
Microsoft.CodeAnalysis.Text.SlidingTextWindow.LexemeStartPosition.get -> int
Microsoft.CodeAnalysis.Text.SlidingTextWindow.MoreChars() -> bool
Microsoft.CodeAnalysis.Text.SlidingTextWindow.NextChar() -> char
Microsoft.CodeAnalysis.Text.SlidingTextWindow.Offset.get -> int
Microsoft.CodeAnalysis.Text.SlidingTextWindow.PeekChar() -> char
Microsoft.CodeAnalysis.Text.SlidingTextWindow.PeekChar(int delta) -> char
Microsoft.CodeAnalysis.Text.SlidingTextWindow.Position.get -> int
Microsoft.CodeAnalysis.Text.SlidingTextWindow.Reset(int position) -> void
Microsoft.CodeAnalysis.Text.SlidingTextWindow.SlidingTextWindow(Microsoft.CodeAnalysis.Text.SourceText text) -> void
Microsoft.CodeAnalysis.Text.SlidingTextWindow.Start() -> void
Microsoft.CodeAnalysis.Text.SlidingTextWindow.Text.get -> Microsoft.CodeAnalysis.Text.SourceText
Microsoft.CodeAnalysis.Text.SlidingTextWindow.Width.get -> int
Microsoft.CodeAnalysis.Text.SourceHashAlgorithm
Microsoft.CodeAnalysis.Text.SourceHashAlgorithm.None = 0 -> Microsoft.CodeAnalysis.Text.SourceHashAlgorithm
Microsoft.CodeAnalysis.Text.SourceHashAlgorithm.Sha1 = 1 -> Microsoft.CodeAnalysis.Text.SourceHashAlgorithm
Microsoft.CodeAnalysis.Text.SourceHashAlgorithm.Sha256 = 2 -> Microsoft.CodeAnalysis.Text.SourceHashAlgorithm
Microsoft.CodeAnalysis.Text.SourceText
Microsoft.CodeAnalysis.Text.SourceText.CanBeEmbedded.get -> bool
Microsoft.CodeAnalysis.Text.SourceText.ChecksumAlgorithm.get -> Microsoft.CodeAnalysis.Text.SourceHashAlgorithm
Microsoft.CodeAnalysis.Text.SourceText.ContentEquals(Microsoft.CodeAnalysis.Text.SourceText other) -> bool
Microsoft.CodeAnalysis.Text.SourceText.GetChecksum() -> System.Collections.Immutable.ImmutableArray<byte>
Microsoft.CodeAnalysis.Text.SourceText.GetSubText(int start) -> Microsoft.CodeAnalysis.Text.SourceText
Microsoft.CodeAnalysis.Text.SourceText.Lines.get -> Microsoft.CodeAnalysis.Text.TextLineCollection
Microsoft.CodeAnalysis.Text.SourceText.Replace(Microsoft.CodeAnalysis.Text.TextSpan span, string newText) -> Microsoft.CodeAnalysis.Text.SourceText
Microsoft.CodeAnalysis.Text.SourceText.Replace(int start, int length, string newText) -> Microsoft.CodeAnalysis.Text.SourceText
Microsoft.CodeAnalysis.Text.SourceText.SourceText(System.Collections.Immutable.ImmutableArray<byte> checksum = default(System.Collections.Immutable.ImmutableArray<byte>), Microsoft.CodeAnalysis.Text.SourceHashAlgorithm checksumAlgorithm = Microsoft.CodeAnalysis.Text.SourceHashAlgorithm.Sha1, Microsoft.CodeAnalysis.Text.SourceTextContainer container = null) -> void
Microsoft.CodeAnalysis.Text.SourceText.ToCharArray() -> char[]
Microsoft.CodeAnalysis.Text.SourceText.WithChanges(params Microsoft.CodeAnalysis.Text.TextChange[] changes) -> Microsoft.CodeAnalysis.Text.SourceText
Microsoft.CodeAnalysis.Text.SourceText.Write(System.IO.TextWriter textWriter, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> void
Microsoft.CodeAnalysis.Text.SourceTextComparer
Microsoft.CodeAnalysis.Text.SourceTextComparer.Equals(Microsoft.CodeAnalysis.Text.SourceText x, Microsoft.CodeAnalysis.Text.SourceText y) -> bool
Microsoft.CodeAnalysis.Text.SourceTextComparer.GetHashCode(Microsoft.CodeAnalysis.Text.SourceText obj) -> int
Microsoft.CodeAnalysis.Text.SourceTextComparer.SourceTextComparer() -> void
Microsoft.CodeAnalysis.Text.SourceTextContainer
Microsoft.CodeAnalysis.Text.SourceTextContainer.SourceTextContainer() -> void
Microsoft.CodeAnalysis.Text.SourceTextStream
Microsoft.CodeAnalysis.Text.SourceTextStream.SourceTextStream(Microsoft.CodeAnalysis.Text.SourceText source, int bufferSize = 2048, bool useDefaultEncodingIfNull = false) -> void
Microsoft.CodeAnalysis.Text.SourceTextWriter
Microsoft.CodeAnalysis.Text.SourceTextWriter.SourceTextWriter() -> void
Microsoft.CodeAnalysis.Text.StringBuilderText
Microsoft.CodeAnalysis.Text.StringBuilderText.StringBuilderText(System.Text.StringBuilder builder, System.Text.Encoding encodingOpt, Microsoft.CodeAnalysis.Text.SourceHashAlgorithm checksumAlgorithm) -> void
Microsoft.CodeAnalysis.Text.StringText
Microsoft.CodeAnalysis.Text.StringText.Source.get -> string
Microsoft.CodeAnalysis.Text.StringTextWriter
Microsoft.CodeAnalysis.Text.StringTextWriter.StringTextWriter(System.Text.Encoding encoding, Microsoft.CodeAnalysis.Text.SourceHashAlgorithm checksumAlgorithm, int capacity) -> void
Microsoft.CodeAnalysis.Text.SubText
Microsoft.CodeAnalysis.Text.SubText.SubText(Microsoft.CodeAnalysis.Text.SourceText text, Microsoft.CodeAnalysis.Text.TextSpan span) -> void
Microsoft.CodeAnalysis.Text.SubText.UnderlyingSpan.get -> Microsoft.CodeAnalysis.Text.TextSpan
Microsoft.CodeAnalysis.Text.SubText.UnderlyingText.get -> Microsoft.CodeAnalysis.Text.SourceText
Microsoft.CodeAnalysis.Text.TextChange
Microsoft.CodeAnalysis.Text.TextChange.Equals(Microsoft.CodeAnalysis.Text.TextChange other) -> bool
Microsoft.CodeAnalysis.Text.TextChange.NewText.get -> string
Microsoft.CodeAnalysis.Text.TextChange.Span.get -> Microsoft.CodeAnalysis.Text.TextSpan
Microsoft.CodeAnalysis.Text.TextChange.TextChange(Microsoft.CodeAnalysis.Text.TextSpan span, string newText) -> void
Microsoft.CodeAnalysis.Text.TextChangeEventArgs
Microsoft.CodeAnalysis.Text.TextChangeEventArgs.Changes.get -> System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.Text.TextChangeRange>
Microsoft.CodeAnalysis.Text.TextChangeEventArgs.NewText.get -> Microsoft.CodeAnalysis.Text.SourceText
Microsoft.CodeAnalysis.Text.TextChangeEventArgs.OldText.get -> Microsoft.CodeAnalysis.Text.SourceText
Microsoft.CodeAnalysis.Text.TextChangeEventArgs.TextChangeEventArgs(Microsoft.CodeAnalysis.Text.SourceText oldText, Microsoft.CodeAnalysis.Text.SourceText newText, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Text.TextChangeRange> changes) -> void
Microsoft.CodeAnalysis.Text.TextChangeEventArgs.TextChangeEventArgs(Microsoft.CodeAnalysis.Text.SourceText oldText, Microsoft.CodeAnalysis.Text.SourceText newText, params Microsoft.CodeAnalysis.Text.TextChangeRange[] changes) -> void
Microsoft.CodeAnalysis.Text.TextChangeRange
Microsoft.CodeAnalysis.Text.TextChangeRange.Equals(Microsoft.CodeAnalysis.Text.TextChangeRange other) -> bool
Microsoft.CodeAnalysis.Text.TextChangeRange.NewLength.get -> int
Microsoft.CodeAnalysis.Text.TextChangeRange.Span.get -> Microsoft.CodeAnalysis.Text.TextSpan
Microsoft.CodeAnalysis.Text.TextChangeRange.TextChangeRange(Microsoft.CodeAnalysis.Text.TextSpan span, int newLength) -> void
Microsoft.CodeAnalysis.Text.TextLine
Microsoft.CodeAnalysis.Text.TextLine.End.get -> int
Microsoft.CodeAnalysis.Text.TextLine.EndIncludingLineBreak.get -> int
Microsoft.CodeAnalysis.Text.TextLine.Equals(Microsoft.CodeAnalysis.Text.TextLine other) -> bool
Microsoft.CodeAnalysis.Text.TextLine.LineNumber.get -> int
Microsoft.CodeAnalysis.Text.TextLine.Span.get -> Microsoft.CodeAnalysis.Text.TextSpan
Microsoft.CodeAnalysis.Text.TextLine.SpanIncludingLineBreak.get -> Microsoft.CodeAnalysis.Text.TextSpan
Microsoft.CodeAnalysis.Text.TextLine.Start.get -> int
Microsoft.CodeAnalysis.Text.TextLine.Text.get -> Microsoft.CodeAnalysis.Text.SourceText
Microsoft.CodeAnalysis.Text.TextLineCollection
Microsoft.CodeAnalysis.Text.TextLineCollection.Enumerator
Microsoft.CodeAnalysis.Text.TextLineCollection.Enumerator.Current.get -> Microsoft.CodeAnalysis.Text.TextLine
Microsoft.CodeAnalysis.Text.TextLineCollection.Enumerator.MoveNext() -> bool
Microsoft.CodeAnalysis.Text.TextLineCollection.GetEnumerator() -> Microsoft.CodeAnalysis.Text.TextLineCollection.Enumerator
Microsoft.CodeAnalysis.Text.TextLineCollection.GetLinePositionSpan(Microsoft.CodeAnalysis.Text.TextSpan span) -> Microsoft.CodeAnalysis.Text.LinePositionSpan
Microsoft.CodeAnalysis.Text.TextLineCollection.GetPosition(Microsoft.CodeAnalysis.Text.LinePosition position) -> int
Microsoft.CodeAnalysis.Text.TextLineCollection.GetTextSpan(Microsoft.CodeAnalysis.Text.LinePositionSpan span) -> Microsoft.CodeAnalysis.Text.TextSpan
Microsoft.CodeAnalysis.Text.TextLineCollection.TextLineCollection() -> void
Microsoft.CodeAnalysis.Text.TextSpan
Microsoft.CodeAnalysis.Text.TextSpan.CompareTo(Microsoft.CodeAnalysis.Text.TextSpan other) -> int
Microsoft.CodeAnalysis.Text.TextSpan.Contains(Microsoft.CodeAnalysis.Text.TextSpan span) -> bool
Microsoft.CodeAnalysis.Text.TextSpan.Contains(int position) -> bool
Microsoft.CodeAnalysis.Text.TextSpan.End.get -> int
Microsoft.CodeAnalysis.Text.TextSpan.Equals(Microsoft.CodeAnalysis.Text.TextSpan other) -> bool
Microsoft.CodeAnalysis.Text.TextSpan.Intersection(Microsoft.CodeAnalysis.Text.TextSpan span) -> Microsoft.CodeAnalysis.Text.TextSpan?
Microsoft.CodeAnalysis.Text.TextSpan.IntersectsWith(Microsoft.CodeAnalysis.Text.TextSpan span) -> bool
Microsoft.CodeAnalysis.Text.TextSpan.IntersectsWith(int position) -> bool
Microsoft.CodeAnalysis.Text.TextSpan.IsEmpty.get -> bool
Microsoft.CodeAnalysis.Text.TextSpan.Length.get -> int
Microsoft.CodeAnalysis.Text.TextSpan.Overlap(Microsoft.CodeAnalysis.Text.TextSpan span) -> Microsoft.CodeAnalysis.Text.TextSpan?
Microsoft.CodeAnalysis.Text.TextSpan.OverlapsWith(Microsoft.CodeAnalysis.Text.TextSpan span) -> bool
Microsoft.CodeAnalysis.Text.TextSpan.Start.get -> int
Microsoft.CodeAnalysis.Text.TextSpan.TextSpan(int start, int length) -> void
Microsoft.CodeAnalysis.Text.TextUtilities
Microsoft.CodeAnalysis.ThreeState
Microsoft.CodeAnalysis.ThreeState.False = 1 -> Microsoft.CodeAnalysis.ThreeState
Microsoft.CodeAnalysis.ThreeState.True = 2 -> Microsoft.CodeAnalysis.ThreeState
Microsoft.CodeAnalysis.ThreeState.Unknown = 0 -> Microsoft.CodeAnalysis.ThreeState
Microsoft.CodeAnalysis.ThreeStateHelpers
Microsoft.CodeAnalysis.UnionCollection<T>
Microsoft.CodeAnalysis.UnionCollection<T>.Add(T item) -> void
Microsoft.CodeAnalysis.UnionCollection<T>.Clear() -> void
Microsoft.CodeAnalysis.UnionCollection<T>.Contains(T item) -> bool
Microsoft.CodeAnalysis.UnionCollection<T>.CopyTo(T[] array, int arrayIndex) -> void
Microsoft.CodeAnalysis.UnionCollection<T>.Count.get -> int
Microsoft.CodeAnalysis.UnionCollection<T>.GetEnumerator() -> System.Collections.Generic.IEnumerator<T>
Microsoft.CodeAnalysis.UnionCollection<T>.IsReadOnly.get -> bool
Microsoft.CodeAnalysis.UnionCollection<T>.Remove(T item) -> bool
Microsoft.CodeAnalysis.WellKnownDiagnosticTags
Roslyn.Utilities.ArrayExtensions
Roslyn.Utilities.BitArithmeticUtilities
Roslyn.Utilities.BlobBuildingStream
Roslyn.Utilities.BlobBuildingStream.Free() -> void
Roslyn.Utilities.BlobBuildingStream.ReserveBytes(int byteCount) -> System.Reflection.Metadata.Blob
Roslyn.Utilities.BlobBuildingStream.ToImmutableArray() -> System.Collections.Immutable.ImmutableArray<byte>
Roslyn.Utilities.BlobBuildingStream.WriteInt32(int value) -> void
Roslyn.Utilities.CharFacts
Roslyn.Utilities.CodeAnalysisResources
Roslyn.Utilities.CommandLineUtilities
Roslyn.Utilities.CompilerOptionParseUtilities
Roslyn.Utilities.ConcurrentDictionaryExtensions
Roslyn.Utilities.ConcurrentSet<T>
Roslyn.Utilities.ConcurrentSet<T>.Add(T value) -> bool
Roslyn.Utilities.ConcurrentSet<T>.AddRange(System.Collections.Generic.IEnumerable<T> values) -> void
Roslyn.Utilities.ConcurrentSet<T>.Clear() -> void
Roslyn.Utilities.ConcurrentSet<T>.ConcurrentSet() -> void
Roslyn.Utilities.ConcurrentSet<T>.ConcurrentSet(System.Collections.Generic.IEqualityComparer<T> equalityComparer) -> void
Roslyn.Utilities.ConcurrentSet<T>.Contains(T value) -> bool
Roslyn.Utilities.ConcurrentSet<T>.CopyTo(T[] array, int arrayIndex) -> void
Roslyn.Utilities.ConcurrentSet<T>.Count.get -> int
Roslyn.Utilities.ConcurrentSet<T>.GetEnumerator() -> Roslyn.Utilities.ConcurrentSet<T>.KeyEnumerator
Roslyn.Utilities.ConcurrentSet<T>.IsEmpty.get -> bool
Roslyn.Utilities.ConcurrentSet<T>.IsReadOnly.get -> bool
Roslyn.Utilities.ConcurrentSet<T>.KeyEnumerator
Roslyn.Utilities.ConcurrentSet<T>.KeyEnumerator.Current.get -> T
Roslyn.Utilities.ConcurrentSet<T>.KeyEnumerator.MoveNext() -> bool
Roslyn.Utilities.ConcurrentSet<T>.KeyEnumerator.Reset() -> void
Roslyn.Utilities.ConcurrentSet<T>.Remove(T value) -> bool
Roslyn.Utilities.ConsList<T>
Roslyn.Utilities.ConsList<T>.Any() -> bool
Roslyn.Utilities.ConsList<T>.ConsList(T head, Roslyn.Utilities.ConsList<T> tail) -> void
Roslyn.Utilities.ConsList<T>.Enumerator
Roslyn.Utilities.ConsList<T>.Enumerator.Current.get -> T
Roslyn.Utilities.ConsList<T>.Enumerator.Dispose() -> void
Roslyn.Utilities.ConsList<T>.Enumerator.MoveNext() -> bool
Roslyn.Utilities.ConsList<T>.Enumerator.Reset() -> void
Roslyn.Utilities.ConsList<T>.GetEnumerator() -> Roslyn.Utilities.ConsList<T>.Enumerator
Roslyn.Utilities.ConsList<T>.Head.get -> T
Roslyn.Utilities.ConsList<T>.Push(T value) -> Roslyn.Utilities.ConsList<T>
Roslyn.Utilities.ConsList<T>.Tail.get -> Roslyn.Utilities.ConsList<T>
Roslyn.Utilities.DecimalUtilities
Roslyn.Utilities.EmptyComparer
Roslyn.Utilities.EncodingExtensions
Roslyn.Utilities.EnumerableExtensions
Roslyn.Utilities.ExceptionUtilities
Roslyn.Utilities.FileNameUtilities
Roslyn.Utilities.FileUtilities
Roslyn.Utilities.Functions<T>
Roslyn.Utilities.Hash
Roslyn.Utilities.HexUtilities
Roslyn.Utilities.IObjectWritable
Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization.get -> bool
Roslyn.Utilities.IObjectWritable.WriteTo(Roslyn.Utilities.ObjectWriter writer) -> void
Roslyn.Utilities.IReadOnlySet<T>
Roslyn.Utilities.IReadOnlySet<T>.Contains(T item) -> bool
Roslyn.Utilities.IReadOnlySet<T>.Count.get -> int
Roslyn.Utilities.ISetExtensions
Roslyn.Utilities.ImmutableArrayExtensions
Roslyn.Utilities.ImmutableByteArrayInterop
Roslyn.Utilities.ImmutableInt32ArrayInterop
Roslyn.Utilities.ImmutableListExtensions
Roslyn.Utilities.ImmutableSetWithInsertionOrder<T>
Roslyn.Utilities.ImmutableSetWithInsertionOrder<T>.Add(T value) -> Roslyn.Utilities.ImmutableSetWithInsertionOrder<T>
Roslyn.Utilities.ImmutableSetWithInsertionOrder<T>.Contains(T value) -> bool
Roslyn.Utilities.ImmutableSetWithInsertionOrder<T>.Count.get -> int
Roslyn.Utilities.ImmutableSetWithInsertionOrder<T>.GetEnumerator() -> System.Collections.Generic.IEnumerator<T>
Roslyn.Utilities.ImmutableSetWithInsertionOrder<T>.InInsertionOrder.get -> System.Collections.Generic.IEnumerable<T>
Roslyn.Utilities.ImmutableSetWithInsertionOrder<T>.Remove(T value) -> Roslyn.Utilities.ImmutableSetWithInsertionOrder<T>
Roslyn.Utilities.InterlockedOperations
Roslyn.Utilities.JsonWriter
Roslyn.Utilities.JsonWriter.Dispose() -> void
Roslyn.Utilities.JsonWriter.JsonWriter(System.IO.TextWriter output) -> void
Roslyn.Utilities.JsonWriter.Write(bool value) -> void
Roslyn.Utilities.JsonWriter.Write(int value) -> void
Roslyn.Utilities.JsonWriter.Write(string key, bool value) -> void
Roslyn.Utilities.JsonWriter.Write(string key, int value) -> void
Roslyn.Utilities.JsonWriter.Write(string key, string value) -> void
Roslyn.Utilities.JsonWriter.Write(string value) -> void
Roslyn.Utilities.JsonWriter.WriteArrayEnd() -> void
Roslyn.Utilities.JsonWriter.WriteArrayStart() -> void
Roslyn.Utilities.JsonWriter.WriteArrayStart(string key) -> void
Roslyn.Utilities.JsonWriter.WriteKey(string key) -> void
Roslyn.Utilities.JsonWriter.WriteObjectEnd() -> void
Roslyn.Utilities.JsonWriter.WriteObjectStart() -> void
Roslyn.Utilities.JsonWriter.WriteObjectStart(string key) -> void
Roslyn.Utilities.MultiDictionary<K, V>
Roslyn.Utilities.MultiDictionary<K, V>.Add(K k, V v) -> void
Roslyn.Utilities.MultiDictionary<K, V>.Clear() -> void
Roslyn.Utilities.MultiDictionary<K, V>.ContainsKey(K k) -> bool
Roslyn.Utilities.MultiDictionary<K, V>.Count.get -> int
Roslyn.Utilities.MultiDictionary<K, V>.GetEnumerator() -> System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<K, Roslyn.Utilities.MultiDictionary<K, V>.ValueSet>>
Roslyn.Utilities.MultiDictionary<K, V>.Keys.get -> System.Collections.Generic.IEnumerable<K>
Roslyn.Utilities.MultiDictionary<K, V>.MultiDictionary() -> void
Roslyn.Utilities.MultiDictionary<K, V>.MultiDictionary(System.Collections.Generic.IEqualityComparer<K> comparer) -> void
Roslyn.Utilities.MultiDictionary<K, V>.MultiDictionary(int capacity, System.Collections.Generic.IEqualityComparer<K> comparer) -> void
Roslyn.Utilities.MultiDictionary<K, V>.Remove(K key) -> void
Roslyn.Utilities.MultiDictionary<K, V>.ValueSet
Roslyn.Utilities.MultiDictionary<K, V>.ValueSet.Add(V v) -> Roslyn.Utilities.MultiDictionary<K, V>.ValueSet
Roslyn.Utilities.MultiDictionary<K, V>.ValueSet.Count.get -> int
Roslyn.Utilities.MultiDictionary<K, V>.ValueSet.Enumerator
Roslyn.Utilities.MultiDictionary<K, V>.ValueSet.Enumerator.Current.get -> V
Roslyn.Utilities.MultiDictionary<K, V>.ValueSet.Enumerator.Dispose() -> void
Roslyn.Utilities.MultiDictionary<K, V>.ValueSet.Enumerator.Enumerator(Roslyn.Utilities.MultiDictionary<K, V>.ValueSet v) -> void
Roslyn.Utilities.MultiDictionary<K, V>.ValueSet.Enumerator.MoveNext() -> bool
Roslyn.Utilities.MultiDictionary<K, V>.ValueSet.Enumerator.Reset() -> void
Roslyn.Utilities.MultiDictionary<K, V>.ValueSet.GetEnumerator() -> Roslyn.Utilities.MultiDictionary<K, V>.ValueSet.Enumerator
Roslyn.Utilities.MultiDictionary<K, V>.ValueSet.Single() -> V
Roslyn.Utilities.MultiDictionary<K, V>.ValueSet.ValueSet(object value) -> void
Roslyn.Utilities.MultiDictionary<K, V>.this[K k].get -> Roslyn.Utilities.MultiDictionary<K, V>.ValueSet
Roslyn.Utilities.NoThrowStreamDisposer
Roslyn.Utilities.NoThrowStreamDisposer.Dispose() -> void
Roslyn.Utilities.NoThrowStreamDisposer.HasFailedToDispose.get -> bool
Roslyn.Utilities.NoThrowStreamDisposer.NoThrowStreamDisposer(System.IO.Stream stream, string filePath, Microsoft.CodeAnalysis.DiagnosticBag diagnostics, Microsoft.CodeAnalysis.CommonMessageProvider messageProvider) -> void
Roslyn.Utilities.NoThrowStreamDisposer.Stream.get -> System.IO.Stream
Roslyn.Utilities.ObjectBinder
Roslyn.Utilities.ObjectBinderSnapshot
Roslyn.Utilities.ObjectBinderSnapshot.GetTypeFromId(int typeId) -> System.Type
Roslyn.Utilities.ObjectBinderSnapshot.GetTypeId(System.Type type) -> int
Roslyn.Utilities.ObjectBinderSnapshot.GetTypeReaderFromId(int typeId) -> System.Func<Roslyn.Utilities.ObjectReader, object>
Roslyn.Utilities.ObjectBinderSnapshot.ObjectBinderSnapshot(System.Collections.Generic.Dictionary<System.Type, int> typeToIndex, System.Collections.Generic.List<System.Type> types, System.Collections.Generic.List<System.Func<Roslyn.Utilities.ObjectReader, object>> typeReaders) -> void
Roslyn.Utilities.ObjectReader
Roslyn.Utilities.ObjectReader.Dispose() -> void
Roslyn.Utilities.ObjectReader.ReadBoolean() -> bool
Roslyn.Utilities.ObjectReader.ReadByte() -> byte
Roslyn.Utilities.ObjectReader.ReadChar() -> char
Roslyn.Utilities.ObjectReader.ReadCompressedUInt() -> uint
Roslyn.Utilities.ObjectReader.ReadDecimal() -> decimal
Roslyn.Utilities.ObjectReader.ReadDouble() -> double
Roslyn.Utilities.ObjectReader.ReadGuid() -> System.Guid
Roslyn.Utilities.ObjectReader.ReadInt16() -> short
Roslyn.Utilities.ObjectReader.ReadInt32() -> int
Roslyn.Utilities.ObjectReader.ReadInt64() -> long
Roslyn.Utilities.ObjectReader.ReadSByte() -> sbyte
Roslyn.Utilities.ObjectReader.ReadSingle() -> float
Roslyn.Utilities.ObjectReader.ReadString() -> string
Roslyn.Utilities.ObjectReader.ReadType() -> System.Type
Roslyn.Utilities.ObjectReader.ReadUInt16() -> ushort
Roslyn.Utilities.ObjectReader.ReadUInt32() -> uint
Roslyn.Utilities.ObjectReader.ReadUInt64() -> ulong
Roslyn.Utilities.ObjectReader.ReadValue() -> object
Roslyn.Utilities.ObjectWriter
Roslyn.Utilities.ObjectWriter.Dispose() -> void
Roslyn.Utilities.ObjectWriter.ObjectWriter(System.IO.Stream stream, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> void
Roslyn.Utilities.ObjectWriter.WriteBoolean(bool value) -> void
Roslyn.Utilities.ObjectWriter.WriteByte(byte value) -> void
Roslyn.Utilities.ObjectWriter.WriteChar(char ch) -> void
Roslyn.Utilities.ObjectWriter.WriteCompressedUInt(uint value) -> void
Roslyn.Utilities.ObjectWriter.WriteDecimal(decimal value) -> void
Roslyn.Utilities.ObjectWriter.WriteDouble(double value) -> void
Roslyn.Utilities.ObjectWriter.WriteGuid(System.Guid guid) -> void
Roslyn.Utilities.ObjectWriter.WriteInt16(short value) -> void
Roslyn.Utilities.ObjectWriter.WriteInt32(int value) -> void
Roslyn.Utilities.ObjectWriter.WriteInt64(long value) -> void
Roslyn.Utilities.ObjectWriter.WriteSByte(sbyte value) -> void
Roslyn.Utilities.ObjectWriter.WriteSingle(float value) -> void
Roslyn.Utilities.ObjectWriter.WriteString(string value) -> void
Roslyn.Utilities.ObjectWriter.WriteType(System.Type type) -> void
Roslyn.Utilities.ObjectWriter.WriteUInt16(ushort value) -> void
Roslyn.Utilities.ObjectWriter.WriteUInt32(uint value) -> void
Roslyn.Utilities.ObjectWriter.WriteUInt64(ulong value) -> void
Roslyn.Utilities.ObjectWriter.WriteValue(Roslyn.Utilities.IObjectWritable value) -> void
Roslyn.Utilities.ObjectWriter.WriteValue(object value) -> void
Roslyn.Utilities.OneOrMany
Roslyn.Utilities.OneOrMany<T>
Roslyn.Utilities.OneOrMany<T>.Add(T one) -> Roslyn.Utilities.OneOrMany<T>
Roslyn.Utilities.OneOrMany<T>.Contains(T item) -> bool
Roslyn.Utilities.OneOrMany<T>.Count.get -> int
Roslyn.Utilities.OneOrMany<T>.Enumerator
Roslyn.Utilities.OneOrMany<T>.Enumerator.Current.get -> T
Roslyn.Utilities.OneOrMany<T>.Enumerator.MoveNext() -> bool
Roslyn.Utilities.OneOrMany<T>.GetEnumerator() -> Roslyn.Utilities.OneOrMany<T>.Enumerator
Roslyn.Utilities.OneOrMany<T>.OneOrMany(System.Collections.Immutable.ImmutableArray<T> many) -> void
Roslyn.Utilities.OneOrMany<T>.OneOrMany(T one) -> void
Roslyn.Utilities.OneOrMany<T>.RemoveAll(T item) -> Roslyn.Utilities.OneOrMany<T>
Roslyn.Utilities.OneOrMany<T>.this[int index].get -> T
Roslyn.Utilities.OrderedMultiDictionary<K, V>
Roslyn.Utilities.OrderedMultiDictionary<K, V>.Add(K k, V v) -> void
Roslyn.Utilities.OrderedMultiDictionary<K, V>.Count.get -> int
Roslyn.Utilities.OrderedMultiDictionary<K, V>.GetEnumerator() -> System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<K, Roslyn.Utilities.SetWithInsertionOrder<V>>>
Roslyn.Utilities.OrderedMultiDictionary<K, V>.Keys.get -> System.Collections.Generic.IEnumerable<K>
Roslyn.Utilities.OrderedMultiDictionary<K, V>.OrderedMultiDictionary() -> void
Roslyn.Utilities.OrderedMultiDictionary<K, V>.this[K k].get -> Roslyn.Utilities.SetWithInsertionOrder<V>
Roslyn.Utilities.PathKind
Roslyn.Utilities.PathKind.Absolute = 6 -> Roslyn.Utilities.PathKind
Roslyn.Utilities.PathKind.Empty = 0 -> Roslyn.Utilities.PathKind
Roslyn.Utilities.PathKind.Relative = 1 -> Roslyn.Utilities.PathKind
Roslyn.Utilities.PathKind.RelativeToCurrentDirectory = 2 -> Roslyn.Utilities.PathKind
Roslyn.Utilities.PathKind.RelativeToCurrentParent = 3 -> Roslyn.Utilities.PathKind
Roslyn.Utilities.PathKind.RelativeToCurrentRoot = 4 -> Roslyn.Utilities.PathKind
Roslyn.Utilities.PathKind.RelativeToDriveDirectory = 5 -> Roslyn.Utilities.PathKind
Roslyn.Utilities.PathUtilities
Roslyn.Utilities.PerformanceSensitiveAttribute
Roslyn.Utilities.PerformanceSensitiveAttribute.AllowCaptures.get -> bool
Roslyn.Utilities.PerformanceSensitiveAttribute.AllowCaptures.set -> void
Roslyn.Utilities.PerformanceSensitiveAttribute.AllowGenericEnumeration.get -> bool
Roslyn.Utilities.PerformanceSensitiveAttribute.AllowGenericEnumeration.set -> void
Roslyn.Utilities.PerformanceSensitiveAttribute.AllowLocks.get -> bool
Roslyn.Utilities.PerformanceSensitiveAttribute.AllowLocks.set -> void
Roslyn.Utilities.PerformanceSensitiveAttribute.Constraint.get -> string
Roslyn.Utilities.PerformanceSensitiveAttribute.Constraint.set -> void
Roslyn.Utilities.PerformanceSensitiveAttribute.IsParallelEntry.get -> bool
Roslyn.Utilities.PerformanceSensitiveAttribute.IsParallelEntry.set -> void
Roslyn.Utilities.PerformanceSensitiveAttribute.OftenCompletesSynchronously.get -> bool
Roslyn.Utilities.PerformanceSensitiveAttribute.OftenCompletesSynchronously.set -> void
Roslyn.Utilities.PerformanceSensitiveAttribute.PerformanceSensitiveAttribute(string uri) -> void
Roslyn.Utilities.PerformanceSensitiveAttribute.Uri.get -> string
Roslyn.Utilities.PlatformInformation
Roslyn.Utilities.ReaderWriterLockSlimExtensions
Roslyn.Utilities.ReaderWriterLockSlimExtensions.ReadLockExiter
Roslyn.Utilities.ReaderWriterLockSlimExtensions.ReadLockExiter.Dispose() -> void
Roslyn.Utilities.ReaderWriterLockSlimExtensions.WriteLockExiter
Roslyn.Utilities.ReaderWriterLockSlimExtensions.WriteLockExiter.Dispose() -> void
Roslyn.Utilities.ReferenceEqualityComparer
Roslyn.Utilities.ReflectionUtilities
Roslyn.Utilities.SemaphoreExtensions
Roslyn.Utilities.SemaphoreExtensions.SemaphoreDisposer
Roslyn.Utilities.SemaphoreExtensions.SemaphoreDisposer.Dispose() -> void
Roslyn.Utilities.SemaphoreExtensions.SemaphoreDisposer.SemaphoreDisposer(System.Threading.Semaphore semaphore) -> void
Roslyn.Utilities.SemaphoreSlimExtensions
Roslyn.Utilities.SemaphoreSlimExtensions.SemaphoreDisposer
Roslyn.Utilities.SemaphoreSlimExtensions.SemaphoreDisposer.Dispose() -> void
Roslyn.Utilities.SemaphoreSlimExtensions.SemaphoreDisposer.SemaphoreDisposer(System.Threading.SemaphoreSlim semaphore) -> void
Roslyn.Utilities.SetWithInsertionOrder<T>
Roslyn.Utilities.SetWithInsertionOrder<T>.Add(T value) -> bool
Roslyn.Utilities.SetWithInsertionOrder<T>.AsImmutable() -> System.Collections.Immutable.ImmutableArray<T>
Roslyn.Utilities.SetWithInsertionOrder<T>.Contains(T value) -> bool
Roslyn.Utilities.SetWithInsertionOrder<T>.Count.get -> int
Roslyn.Utilities.SetWithInsertionOrder<T>.GetEnumerator() -> System.Collections.Generic.IEnumerator<T>
Roslyn.Utilities.SetWithInsertionOrder<T>.Insert(int index, T value) -> bool
Roslyn.Utilities.SetWithInsertionOrder<T>.Remove(T value) -> bool
Roslyn.Utilities.SetWithInsertionOrder<T>.SetWithInsertionOrder() -> void
Roslyn.Utilities.SetWithInsertionOrder<T>.this[int i].get -> T
Roslyn.Utilities.SpecializedCollections
Roslyn.Utilities.StreamExtensions
Roslyn.Utilities.StringExtensions
Roslyn.Utilities.StringOrdinalComparer
Roslyn.Utilities.StringTable
Roslyn.Utilities.StringTable.Add(System.Text.StringBuilder chars) -> string
Roslyn.Utilities.StringTable.Add(char chars) -> string
Roslyn.Utilities.StringTable.Add(char[] chars, int start, int len) -> string
Roslyn.Utilities.StringTable.Add(string chars) -> string
Roslyn.Utilities.StringTable.Add(string chars, int start, int len) -> string
Roslyn.Utilities.StringTable.Free() -> void
Roslyn.Utilities.StringTable.StringTable() -> void
Roslyn.Utilities.TextChangeRangeExtensions
Roslyn.Utilities.TextKeyedCache<T>
Roslyn.Utilities.TextKeyedCache<T>.AddItem(char[] chars, int start, int len, int hashCode, T item) -> void
Roslyn.Utilities.TextKeyedCache<T>.FindItem(char[] chars, int start, int len, int hashCode) -> T
Roslyn.Utilities.TextKeyedCache<T>.Free() -> void
Roslyn.Utilities.TextKeyedCache<T>.TextKeyedCache() -> void
Roslyn.Utilities.ThreadSafeFlagOperations
Roslyn.Utilities.UICultureUtilities
Roslyn.Utilities.UnicodeCharacterUtilities
Roslyn.Utilities.WeakList<T>
Roslyn.Utilities.WeakList<T>.Add(T item) -> void
Roslyn.Utilities.WeakList<T>.GetEnumerator() -> System.Collections.Generic.IEnumerator<T>
Roslyn.Utilities.WeakList<T>.GetWeakReference(int index) -> System.WeakReference<T>
Roslyn.Utilities.WeakList<T>.WeakCount.get -> int
Roslyn.Utilities.WeakList<T>.WeakList() -> void
Roslyn.Utilities.WeakReferenceExtensions
System.Linq.EnumerableExtensions
System.Security.SuppressUnmanagedCodeSecurityAttribute
System.Security.SuppressUnmanagedCodeSecurityAttribute.SuppressUnmanagedCodeSecurityAttribute() -> void
abstract Microsoft.CodeAnalysis.CommonMessageProvider.CodePrefix.get -> string
abstract Microsoft.CodeAnalysis.CommonMessageProvider.CreateDiagnostic(Microsoft.CodeAnalysis.DiagnosticInfo info) -> Microsoft.CodeAnalysis.Diagnostic
abstract Microsoft.CodeAnalysis.CommonMessageProvider.CreateDiagnostic(int code, Microsoft.CodeAnalysis.Location location, params object[] args) -> Microsoft.CodeAnalysis.Diagnostic
abstract Microsoft.CodeAnalysis.CommonMessageProvider.ErrorCodeType.get -> System.Type
abstract Microsoft.CodeAnalysis.CommonMessageProvider.GetCategory(int code) -> string
abstract Microsoft.CodeAnalysis.CommonMessageProvider.GetDescription(int code) -> Microsoft.CodeAnalysis.LocalizableString
abstract Microsoft.CodeAnalysis.CommonMessageProvider.GetDiagnosticReport(Microsoft.CodeAnalysis.DiagnosticInfo diagnosticInfo) -> Microsoft.CodeAnalysis.ReportDiagnostic
abstract Microsoft.CodeAnalysis.CommonMessageProvider.GetHelpLink(int code) -> string
abstract Microsoft.CodeAnalysis.CommonMessageProvider.GetMessageFormat(int code) -> Microsoft.CodeAnalysis.LocalizableString
abstract Microsoft.CodeAnalysis.CommonMessageProvider.GetMessagePrefix(string id, Microsoft.CodeAnalysis.DiagnosticSeverity severity, bool isWarningAsError, System.Globalization.CultureInfo culture) -> string
abstract Microsoft.CodeAnalysis.CommonMessageProvider.GetSeverity(int code) -> Microsoft.CodeAnalysis.DiagnosticSeverity
abstract Microsoft.CodeAnalysis.CommonMessageProvider.GetTitle(int code) -> Microsoft.CodeAnalysis.LocalizableString
abstract Microsoft.CodeAnalysis.CommonMessageProvider.GetWarningLevel(int code) -> int
abstract Microsoft.CodeAnalysis.CommonMessageProvider.LoadMessage(int code, System.Globalization.CultureInfo language) -> string
abstract Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations.get -> System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.Location>
abstract Microsoft.CodeAnalysis.Diagnostic.Descriptor.get -> Microsoft.CodeAnalysis.DiagnosticDescriptor
abstract Microsoft.CodeAnalysis.Diagnostic.Equals(Microsoft.CodeAnalysis.Diagnostic obj) -> bool
abstract Microsoft.CodeAnalysis.Diagnostic.GetMessage(System.IFormatProvider formatProvider = null) -> string
abstract Microsoft.CodeAnalysis.Diagnostic.Id.get -> string
abstract Microsoft.CodeAnalysis.Diagnostic.IsSuppressed.get -> bool
abstract Microsoft.CodeAnalysis.Diagnostic.Location.get -> Microsoft.CodeAnalysis.Location
abstract Microsoft.CodeAnalysis.Diagnostic.Severity.get -> Microsoft.CodeAnalysis.DiagnosticSeverity
abstract Microsoft.CodeAnalysis.Diagnostic.WarningLevel.get -> int
abstract Microsoft.CodeAnalysis.Diagnostic.WithIsSuppressed(bool isSuppressed) -> Microsoft.CodeAnalysis.Diagnostic
abstract Microsoft.CodeAnalysis.Diagnostic.WithLocation(Microsoft.CodeAnalysis.Location location) -> Microsoft.CodeAnalysis.Diagnostic
abstract Microsoft.CodeAnalysis.Diagnostic.WithSeverity(Microsoft.CodeAnalysis.DiagnosticSeverity severity) -> Microsoft.CodeAnalysis.Diagnostic
abstract Microsoft.CodeAnalysis.LocalizableString.AreEqual(object other) -> bool
abstract Microsoft.CodeAnalysis.LocalizableString.GetHash() -> int
abstract Microsoft.CodeAnalysis.LocalizableString.GetText(System.IFormatProvider formatProvider) -> string
abstract Microsoft.CodeAnalysis.Text.SourceText.CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count) -> void
abstract Microsoft.CodeAnalysis.Text.SourceText.Encoding.get -> System.Text.Encoding
abstract Microsoft.CodeAnalysis.Text.SourceText.Length.get -> int
abstract Microsoft.CodeAnalysis.Text.SourceText.this[int position].get -> char
abstract Microsoft.CodeAnalysis.Text.SourceTextContainer.CurrentText.get -> Microsoft.CodeAnalysis.Text.SourceText
abstract Microsoft.CodeAnalysis.Text.SourceTextContainer.TextChanged -> System.EventHandler<Microsoft.CodeAnalysis.Text.TextChangeEventArgs>
abstract Microsoft.CodeAnalysis.Text.SourceTextWriter.ToSourceText() -> Microsoft.CodeAnalysis.Text.SourceText
abstract Microsoft.CodeAnalysis.Text.TextLineCollection.Count.get -> int
abstract Microsoft.CodeAnalysis.Text.TextLineCollection.IndexOf(int position) -> int
abstract Microsoft.CodeAnalysis.Text.TextLineCollection.this[int index].get -> Microsoft.CodeAnalysis.Text.TextLine
const Microsoft.CodeAnalysis.BitVector.BitsPerWord = 32 -> int
const Microsoft.CodeAnalysis.InternalDiagnosticSeverity.Unknown = (Microsoft.CodeAnalysis.DiagnosticSeverity)-1 -> Microsoft.CodeAnalysis.DiagnosticSeverity
const Microsoft.CodeAnalysis.InternalDiagnosticSeverity.Void = (Microsoft.CodeAnalysis.DiagnosticSeverity)-2 -> Microsoft.CodeAnalysis.DiagnosticSeverity
const Microsoft.CodeAnalysis.InternalErrorCode.Unknown = -1 -> int
const Microsoft.CodeAnalysis.InternalErrorCode.Void = -2 -> int
const Microsoft.CodeAnalysis.StackGuard.MaxUncheckedRecursionDepth = 20 -> int
const Microsoft.CodeAnalysis.Text.SlidingTextWindow.InvalidCharacter = '\uffff' -> char
const Microsoft.CodeAnalysis.Text.SourceText.LargeObjectHeapLimitInChars = 40960 -> int
const Microsoft.CodeAnalysis.WellKnownDiagnosticTags.AnalyzerException = "AnalyzerException" -> string
const Microsoft.CodeAnalysis.WellKnownDiagnosticTags.Build = "Build" -> string
const Microsoft.CodeAnalysis.WellKnownDiagnosticTags.Compiler = "Compiler" -> string
const Microsoft.CodeAnalysis.WellKnownDiagnosticTags.EditAndContinue = "EditAndContinue" -> string
const Microsoft.CodeAnalysis.WellKnownDiagnosticTags.NotConfigurable = "NotConfigurable" -> string
const Microsoft.CodeAnalysis.WellKnownDiagnosticTags.Telemetry = "Telemetry" -> string
const Microsoft.CodeAnalysis.WellKnownDiagnosticTags.Unnecessary = "Unnecessary" -> string
const Roslyn.Utilities.BlobBuildingStream.ChunkSize = 32768 -> int
override Microsoft.CodeAnalysis.BitVector.Equals(object obj) -> bool
override Microsoft.CodeAnalysis.BitVector.GetHashCode() -> int
override Microsoft.CodeAnalysis.Collections.ImmutableMemoryStream.CanRead.get -> bool
override Microsoft.CodeAnalysis.Collections.ImmutableMemoryStream.CanSeek.get -> bool
override Microsoft.CodeAnalysis.Collections.ImmutableMemoryStream.CanWrite.get -> bool
override Microsoft.CodeAnalysis.Collections.ImmutableMemoryStream.Flush() -> void
override Microsoft.CodeAnalysis.Collections.ImmutableMemoryStream.Length.get -> long
override Microsoft.CodeAnalysis.Collections.ImmutableMemoryStream.Position.get -> long
override Microsoft.CodeAnalysis.Collections.ImmutableMemoryStream.Position.set -> void
override Microsoft.CodeAnalysis.Collections.ImmutableMemoryStream.Read(byte[] buffer, int offset, int count) -> int
override Microsoft.CodeAnalysis.Collections.ImmutableMemoryStream.Seek(long offset, System.IO.SeekOrigin origin) -> long
override Microsoft.CodeAnalysis.Collections.ImmutableMemoryStream.SetLength(long value) -> void
override Microsoft.CodeAnalysis.Collections.ImmutableMemoryStream.Write(byte[] buffer, int offset, int count) -> void
override Microsoft.CodeAnalysis.Diagnostic.SimpleDiagnostic.AdditionalLocations.get -> System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.Location>
override Microsoft.CodeAnalysis.Diagnostic.SimpleDiagnostic.Descriptor.get -> Microsoft.CodeAnalysis.DiagnosticDescriptor
override Microsoft.CodeAnalysis.Diagnostic.SimpleDiagnostic.Equals(Microsoft.CodeAnalysis.Diagnostic obj) -> bool
override Microsoft.CodeAnalysis.Diagnostic.SimpleDiagnostic.Equals(object obj) -> bool
override Microsoft.CodeAnalysis.Diagnostic.SimpleDiagnostic.GetHashCode() -> int
override Microsoft.CodeAnalysis.Diagnostic.SimpleDiagnostic.GetMessage(System.IFormatProvider formatProvider = null) -> string
override Microsoft.CodeAnalysis.Diagnostic.SimpleDiagnostic.Id.get -> string
override Microsoft.CodeAnalysis.Diagnostic.SimpleDiagnostic.IsSuppressed.get -> bool
override Microsoft.CodeAnalysis.Diagnostic.SimpleDiagnostic.Location.get -> Microsoft.CodeAnalysis.Location
override Microsoft.CodeAnalysis.Diagnostic.SimpleDiagnostic.Properties.get -> System.Collections.Immutable.ImmutableDictionary<string, string>
override Microsoft.CodeAnalysis.Diagnostic.SimpleDiagnostic.Severity.get -> Microsoft.CodeAnalysis.DiagnosticSeverity
override Microsoft.CodeAnalysis.Diagnostic.SimpleDiagnostic.WarningLevel.get -> int
override Microsoft.CodeAnalysis.Diagnostic.SimpleDiagnostic.WithIsSuppressed(bool isSuppressed) -> Microsoft.CodeAnalysis.Diagnostic
override Microsoft.CodeAnalysis.Diagnostic.SimpleDiagnostic.WithLocation(Microsoft.CodeAnalysis.Location location) -> Microsoft.CodeAnalysis.Diagnostic
override Microsoft.CodeAnalysis.Diagnostic.SimpleDiagnostic.WithSeverity(Microsoft.CodeAnalysis.DiagnosticSeverity severity) -> Microsoft.CodeAnalysis.Diagnostic
override Microsoft.CodeAnalysis.Diagnostic.ToString() -> string
override Microsoft.CodeAnalysis.DiagnosticBag.ToString() -> string
override Microsoft.CodeAnalysis.DiagnosticDescriptor.Equals(object obj) -> bool
override Microsoft.CodeAnalysis.DiagnosticDescriptor.GetHashCode() -> int
override Microsoft.CodeAnalysis.DiagnosticInfo.ToString() -> string
override Microsoft.CodeAnalysis.DiagnosticWithInfo.AdditionalLocations.get -> System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.Location>
override Microsoft.CodeAnalysis.DiagnosticWithInfo.Descriptor.get -> Microsoft.CodeAnalysis.DiagnosticDescriptor
override Microsoft.CodeAnalysis.DiagnosticWithInfo.Equals(Microsoft.CodeAnalysis.Diagnostic obj) -> bool
override Microsoft.CodeAnalysis.DiagnosticWithInfo.Equals(object obj) -> bool
override Microsoft.CodeAnalysis.DiagnosticWithInfo.GetHashCode() -> int
override Microsoft.CodeAnalysis.DiagnosticWithInfo.GetMessage(System.IFormatProvider formatProvider = null) -> string
override Microsoft.CodeAnalysis.DiagnosticWithInfo.Id.get -> string
override Microsoft.CodeAnalysis.DiagnosticWithInfo.IsSuppressed.get -> bool
override Microsoft.CodeAnalysis.DiagnosticWithInfo.Location.get -> Microsoft.CodeAnalysis.Location
override Microsoft.CodeAnalysis.DiagnosticWithInfo.WithIsSuppressed(bool isSuppressed) -> Microsoft.CodeAnalysis.Diagnostic
override Microsoft.CodeAnalysis.DiagnosticWithInfo.WithLocation(Microsoft.CodeAnalysis.Location location) -> Microsoft.CodeAnalysis.Diagnostic
override Microsoft.CodeAnalysis.DiagnosticWithInfo.WithSeverity(Microsoft.CodeAnalysis.DiagnosticSeverity severity) -> Microsoft.CodeAnalysis.Diagnostic
override Microsoft.CodeAnalysis.ExternalFileLocation.Equals(object obj) -> bool
override Microsoft.CodeAnalysis.ExternalFileLocation.GetHashCode() -> int
override Microsoft.CodeAnalysis.ExternalFileLocation.GetLineSpan() -> Microsoft.CodeAnalysis.FileLinePositionSpan
override Microsoft.CodeAnalysis.ExternalFileLocation.GetMappedLineSpan() -> Microsoft.CodeAnalysis.FileLinePositionSpan
override Microsoft.CodeAnalysis.ExternalFileLocation.SourceSpan.get -> Microsoft.CodeAnalysis.Text.TextSpan
override Microsoft.CodeAnalysis.FileLinePositionSpan.Equals(object other) -> bool
override Microsoft.CodeAnalysis.FileLinePositionSpan.GetHashCode() -> int
override Microsoft.CodeAnalysis.FileLinePositionSpan.ToString() -> string
override Microsoft.CodeAnalysis.NoLocation.Equals(object obj) -> bool
override Microsoft.CodeAnalysis.NoLocation.GetHashCode() -> int
override Microsoft.CodeAnalysis.ReadOnlyUnmanagedMemoryStream.CanRead.get -> bool
override Microsoft.CodeAnalysis.ReadOnlyUnmanagedMemoryStream.CanSeek.get -> bool
override Microsoft.CodeAnalysis.ReadOnlyUnmanagedMemoryStream.CanWrite.get -> bool
override Microsoft.CodeAnalysis.ReadOnlyUnmanagedMemoryStream.Flush() -> void
override Microsoft.CodeAnalysis.ReadOnlyUnmanagedMemoryStream.Length.get -> long
override Microsoft.CodeAnalysis.ReadOnlyUnmanagedMemoryStream.Position.get -> long
override Microsoft.CodeAnalysis.ReadOnlyUnmanagedMemoryStream.Position.set -> void
override Microsoft.CodeAnalysis.ReadOnlyUnmanagedMemoryStream.Read(byte[] buffer, int offset, int count) -> int
override Microsoft.CodeAnalysis.ReadOnlyUnmanagedMemoryStream.ReadByte() -> int
override Microsoft.CodeAnalysis.ReadOnlyUnmanagedMemoryStream.Seek(long offset, System.IO.SeekOrigin origin) -> long
override Microsoft.CodeAnalysis.ReadOnlyUnmanagedMemoryStream.SetLength(long value) -> void
override Microsoft.CodeAnalysis.ReadOnlyUnmanagedMemoryStream.Write(byte[] buffer, int offset, int count) -> void
override Microsoft.CodeAnalysis.RelativePathResolver.Equals(object obj) -> bool
override Microsoft.CodeAnalysis.RelativePathResolver.GetHashCode() -> int
override Microsoft.CodeAnalysis.Text.ChangedText.CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count) -> void
override Microsoft.CodeAnalysis.Text.ChangedText.Encoding.get -> System.Text.Encoding
override Microsoft.CodeAnalysis.Text.ChangedText.GetChangeRanges(Microsoft.CodeAnalysis.Text.SourceText oldText) -> System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.Text.TextChangeRange>
override Microsoft.CodeAnalysis.Text.ChangedText.GetSubText(Microsoft.CodeAnalysis.Text.TextSpan span) -> Microsoft.CodeAnalysis.Text.SourceText
override Microsoft.CodeAnalysis.Text.ChangedText.Length.get -> int
override Microsoft.CodeAnalysis.Text.ChangedText.ToString(Microsoft.CodeAnalysis.Text.TextSpan span) -> string
override Microsoft.CodeAnalysis.Text.ChangedText.WithChanges(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Text.TextChange> changes) -> Microsoft.CodeAnalysis.Text.SourceText
override Microsoft.CodeAnalysis.Text.ChangedText.this[int position].get -> char
override Microsoft.CodeAnalysis.Text.CompositeText.CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count) -> void
override Microsoft.CodeAnalysis.Text.CompositeText.Encoding.get -> System.Text.Encoding
override Microsoft.CodeAnalysis.Text.CompositeText.GetSubText(Microsoft.CodeAnalysis.Text.TextSpan span) -> Microsoft.CodeAnalysis.Text.SourceText
override Microsoft.CodeAnalysis.Text.CompositeText.Length.get -> int
override Microsoft.CodeAnalysis.Text.CompositeText.this[int position].get -> char
override Microsoft.CodeAnalysis.Text.LargeText.CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count) -> void
override Microsoft.CodeAnalysis.Text.LargeText.Encoding.get -> System.Text.Encoding
override Microsoft.CodeAnalysis.Text.LargeText.Length.get -> int
override Microsoft.CodeAnalysis.Text.LargeText.Write(System.IO.TextWriter writer, Microsoft.CodeAnalysis.Text.TextSpan span, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> void
override Microsoft.CodeAnalysis.Text.LargeText.this[int position].get -> char
override Microsoft.CodeAnalysis.Text.LargeTextWriter.Encoding.get -> System.Text.Encoding
override Microsoft.CodeAnalysis.Text.LargeTextWriter.Flush() -> void
override Microsoft.CodeAnalysis.Text.LargeTextWriter.ToSourceText() -> Microsoft.CodeAnalysis.Text.SourceText
override Microsoft.CodeAnalysis.Text.LargeTextWriter.Write(char value) -> void
override Microsoft.CodeAnalysis.Text.LargeTextWriter.Write(char[] chars, int index, int count) -> void
override Microsoft.CodeAnalysis.Text.LargeTextWriter.Write(string value) -> void
override Microsoft.CodeAnalysis.Text.LinePosition.Equals(object obj) -> bool
override Microsoft.CodeAnalysis.Text.LinePosition.GetHashCode() -> int
override Microsoft.CodeAnalysis.Text.LinePosition.ToString() -> string
override Microsoft.CodeAnalysis.Text.LinePositionSpan.Equals(object obj) -> bool
override Microsoft.CodeAnalysis.Text.LinePositionSpan.GetHashCode() -> int
override Microsoft.CodeAnalysis.Text.LinePositionSpan.ToString() -> string
override Microsoft.CodeAnalysis.Text.SourceText.ToString() -> string
override Microsoft.CodeAnalysis.Text.SourceTextStream.CanRead.get -> bool
override Microsoft.CodeAnalysis.Text.SourceTextStream.CanSeek.get -> bool
override Microsoft.CodeAnalysis.Text.SourceTextStream.CanWrite.get -> bool
override Microsoft.CodeAnalysis.Text.SourceTextStream.Flush() -> void
override Microsoft.CodeAnalysis.Text.SourceTextStream.Length.get -> long
override Microsoft.CodeAnalysis.Text.SourceTextStream.Position.get -> long
override Microsoft.CodeAnalysis.Text.SourceTextStream.Position.set -> void
override Microsoft.CodeAnalysis.Text.SourceTextStream.Read(byte[] buffer, int offset, int count) -> int
override Microsoft.CodeAnalysis.Text.SourceTextStream.Seek(long offset, System.IO.SeekOrigin origin) -> long
override Microsoft.CodeAnalysis.Text.SourceTextStream.SetLength(long value) -> void
override Microsoft.CodeAnalysis.Text.SourceTextStream.Write(byte[] buffer, int offset, int count) -> void
override Microsoft.CodeAnalysis.Text.StringBuilderText.CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count) -> void
override Microsoft.CodeAnalysis.Text.StringBuilderText.Encoding.get -> System.Text.Encoding
override Microsoft.CodeAnalysis.Text.StringBuilderText.Length.get -> int
override Microsoft.CodeAnalysis.Text.StringBuilderText.ToString(Microsoft.CodeAnalysis.Text.TextSpan span) -> string
override Microsoft.CodeAnalysis.Text.StringBuilderText.this[int position].get -> char
override Microsoft.CodeAnalysis.Text.StringText.CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count) -> void
override Microsoft.CodeAnalysis.Text.StringText.Encoding.get -> System.Text.Encoding
override Microsoft.CodeAnalysis.Text.StringText.Length.get -> int
override Microsoft.CodeAnalysis.Text.StringText.ToString(Microsoft.CodeAnalysis.Text.TextSpan span) -> string
override Microsoft.CodeAnalysis.Text.StringText.Write(System.IO.TextWriter textWriter, Microsoft.CodeAnalysis.Text.TextSpan span, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> void
override Microsoft.CodeAnalysis.Text.StringText.this[int position].get -> char
override Microsoft.CodeAnalysis.Text.StringTextWriter.Encoding.get -> System.Text.Encoding
override Microsoft.CodeAnalysis.Text.StringTextWriter.ToSourceText() -> Microsoft.CodeAnalysis.Text.SourceText
override Microsoft.CodeAnalysis.Text.StringTextWriter.Write(char value) -> void
override Microsoft.CodeAnalysis.Text.StringTextWriter.Write(char[] buffer, int index, int count) -> void
override Microsoft.CodeAnalysis.Text.StringTextWriter.Write(string value) -> void
override Microsoft.CodeAnalysis.Text.SubText.CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count) -> void
override Microsoft.CodeAnalysis.Text.SubText.Encoding.get -> System.Text.Encoding
override Microsoft.CodeAnalysis.Text.SubText.GetSubText(Microsoft.CodeAnalysis.Text.TextSpan span) -> Microsoft.CodeAnalysis.Text.SourceText
override Microsoft.CodeAnalysis.Text.SubText.Length.get -> int
override Microsoft.CodeAnalysis.Text.SubText.ToString(Microsoft.CodeAnalysis.Text.TextSpan span) -> string
override Microsoft.CodeAnalysis.Text.SubText.this[int position].get -> char
override Microsoft.CodeAnalysis.Text.TextChange.Equals(object obj) -> bool
override Microsoft.CodeAnalysis.Text.TextChange.GetHashCode() -> int
override Microsoft.CodeAnalysis.Text.TextChange.ToString() -> string
override Microsoft.CodeAnalysis.Text.TextChangeRange.Equals(object obj) -> bool
override Microsoft.CodeAnalysis.Text.TextChangeRange.GetHashCode() -> int
override Microsoft.CodeAnalysis.Text.TextLine.Equals(object obj) -> bool
override Microsoft.CodeAnalysis.Text.TextLine.GetHashCode() -> int
override Microsoft.CodeAnalysis.Text.TextLine.ToString() -> string
override Microsoft.CodeAnalysis.Text.TextLineCollection.Enumerator.Equals(object obj) -> bool
override Microsoft.CodeAnalysis.Text.TextLineCollection.Enumerator.GetHashCode() -> int
override Microsoft.CodeAnalysis.Text.TextSpan.Equals(object obj) -> bool
override Microsoft.CodeAnalysis.Text.TextSpan.GetHashCode() -> int
override Microsoft.CodeAnalysis.Text.TextSpan.ToString() -> string
override Roslyn.Utilities.BlobBuildingStream.CanRead.get -> bool
override Roslyn.Utilities.BlobBuildingStream.CanSeek.get -> bool
override Roslyn.Utilities.BlobBuildingStream.CanWrite.get -> bool
override Roslyn.Utilities.BlobBuildingStream.Flush() -> void
override Roslyn.Utilities.BlobBuildingStream.Length.get -> long
override Roslyn.Utilities.BlobBuildingStream.Position.get -> long
override Roslyn.Utilities.BlobBuildingStream.Position.set -> void
override Roslyn.Utilities.BlobBuildingStream.Read(byte[] buffer, int offset, int count) -> int
override Roslyn.Utilities.BlobBuildingStream.Seek(long offset, System.IO.SeekOrigin origin) -> long
override Roslyn.Utilities.BlobBuildingStream.SetLength(long value) -> void
override Roslyn.Utilities.BlobBuildingStream.Write(byte[] buffer, int offset, int count) -> void
override Roslyn.Utilities.BlobBuildingStream.WriteByte(byte value) -> void
override Roslyn.Utilities.ConsList<T>.ToString() -> string
override Roslyn.Utilities.ImmutableSetWithInsertionOrder<T>.ToString() -> string
override abstract Microsoft.CodeAnalysis.Diagnostic.Equals(object obj) -> bool
override abstract Microsoft.CodeAnalysis.Diagnostic.GetHashCode() -> int
override abstract Microsoft.CodeAnalysis.Location.Equals(object obj) -> bool
override abstract Microsoft.CodeAnalysis.Location.GetHashCode() -> int
override abstract Microsoft.CodeAnalysis.RequiredLanguageVersion.ToString() -> string
override sealed Microsoft.CodeAnalysis.DiagnosticInfo.Equals(object obj) -> bool
override sealed Microsoft.CodeAnalysis.DiagnosticInfo.GetHashCode() -> int
override sealed Microsoft.CodeAnalysis.DiagnosticWithInfo.DefaultSeverity.get -> Microsoft.CodeAnalysis.DiagnosticSeverity
override sealed Microsoft.CodeAnalysis.DiagnosticWithInfo.Severity.get -> Microsoft.CodeAnalysis.DiagnosticSeverity
override sealed Microsoft.CodeAnalysis.DiagnosticWithInfo.WarningLevel.get -> int
override sealed Microsoft.CodeAnalysis.LocalizableString.Equals(object other) -> bool
override sealed Microsoft.CodeAnalysis.LocalizableString.GetHashCode() -> int
override sealed Microsoft.CodeAnalysis.LocalizableString.ToString() -> string
readonly Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder.Builder -> System.Text.StringBuilder
static Microsoft.CodeAnalysis.ArrayBuilderExtensions.AddIfNotNull<T>(this Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T> builder, T value) -> void
static Microsoft.CodeAnalysis.ArrayBuilderExtensions.AddIfNotNull<T>(this Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T> builder, T? value) -> void
static Microsoft.CodeAnalysis.ArrayBuilderExtensions.AddOptional<T>(this Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T> builder, T item) -> void
static Microsoft.CodeAnalysis.ArrayBuilderExtensions.All<T>(this Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T> builder, System.Func<T, bool> predicate) -> bool
static Microsoft.CodeAnalysis.ArrayBuilderExtensions.Any<T>(this Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T> builder, System.Func<T, bool> predicate) -> bool
static Microsoft.CodeAnalysis.ArrayBuilderExtensions.Peek<T>(this Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T> builder) -> T
static Microsoft.CodeAnalysis.ArrayBuilderExtensions.Pop<T>(this Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T> builder) -> T
static Microsoft.CodeAnalysis.ArrayBuilderExtensions.Push<T>(this Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T> builder, T e) -> void
static Microsoft.CodeAnalysis.ArrayBuilderExtensions.SelectAsArray<TItem, TArg, TResult>(this Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<TItem> items, System.Func<TItem, TArg, TResult> map, TArg arg) -> System.Collections.Immutable.ImmutableArray<TResult>
static Microsoft.CodeAnalysis.ArrayBuilderExtensions.SelectAsArray<TItem, TResult>(this Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<TItem> items, System.Func<TItem, TResult> map) -> System.Collections.Immutable.ImmutableArray<TResult>
static Microsoft.CodeAnalysis.ArrayBuilderExtensions.ToImmutableOrEmptyAndFree<T>(this Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T> builderOpt) -> System.Collections.Immutable.ImmutableArray<T>
static Microsoft.CodeAnalysis.ArrayElement<T>.MakeArray(Microsoft.CodeAnalysis.ArrayElement<T>[] items) -> T[]
static Microsoft.CodeAnalysis.ArrayElement<T>.MakeElementArray(T[] items) -> Microsoft.CodeAnalysis.ArrayElement<T>[]
static Microsoft.CodeAnalysis.ArrayElement<T>.implicit operator T(Microsoft.CodeAnalysis.ArrayElement<T> element) -> T
static Microsoft.CodeAnalysis.BitVector.AllSet(int capacity) -> Microsoft.CodeAnalysis.BitVector
static Microsoft.CodeAnalysis.BitVector.Create(int capacity) -> Microsoft.CodeAnalysis.BitVector
static Microsoft.CodeAnalysis.BitVector.Empty.get -> Microsoft.CodeAnalysis.BitVector
static Microsoft.CodeAnalysis.BitVector.IsTrue(uint word, int index) -> bool
static Microsoft.CodeAnalysis.BitVector.Null.get -> Microsoft.CodeAnalysis.BitVector
static Microsoft.CodeAnalysis.BitVector.WordsRequired(int capacity) -> int
static Microsoft.CodeAnalysis.Boxes.Box(bool b) -> object
static Microsoft.CodeAnalysis.Boxes.Box(byte b) -> object
static Microsoft.CodeAnalysis.Boxes.Box(char c) -> object
static Microsoft.CodeAnalysis.Boxes.Box(decimal d) -> object
static Microsoft.CodeAnalysis.Boxes.Box(double d) -> object
static Microsoft.CodeAnalysis.Boxes.Box(float f) -> object
static Microsoft.CodeAnalysis.Boxes.Box(int i) -> object
static Microsoft.CodeAnalysis.Boxes.Box(long l) -> object
static Microsoft.CodeAnalysis.Boxes.Box(sbyte sb) -> object
static Microsoft.CodeAnalysis.Boxes.Box(short s) -> object
static Microsoft.CodeAnalysis.Boxes.Box(uint u) -> object
static Microsoft.CodeAnalysis.Boxes.Box(ulong ul) -> object
static Microsoft.CodeAnalysis.Boxes.Box(ushort us) -> object
static Microsoft.CodeAnalysis.CachingIdentityFactory<TKey, TValue>.CreatePool(int size, System.Func<TKey, TValue> valueFactory) -> Microsoft.CodeAnalysis.PooledObjects.ObjectPool<Microsoft.CodeAnalysis.CachingIdentityFactory<TKey, TValue>>
static Microsoft.CodeAnalysis.CaseInsensitiveComparison.Compare(string left, string right) -> int
static Microsoft.CodeAnalysis.CaseInsensitiveComparison.Comparer.get -> System.StringComparer
static Microsoft.CodeAnalysis.CaseInsensitiveComparison.EndsWith(string value, string possibleEnd) -> bool
static Microsoft.CodeAnalysis.CaseInsensitiveComparison.Equals(string left, string right) -> bool
static Microsoft.CodeAnalysis.CaseInsensitiveComparison.GetHashCode(string value) -> int
static Microsoft.CodeAnalysis.CaseInsensitiveComparison.StartsWith(string value, string possibleStart) -> bool
static Microsoft.CodeAnalysis.CaseInsensitiveComparison.ToLower(System.Text.StringBuilder builder) -> void
static Microsoft.CodeAnalysis.CaseInsensitiveComparison.ToLower(char c) -> char
static Microsoft.CodeAnalysis.CaseInsensitiveComparison.ToLower(string value) -> string
static Microsoft.CodeAnalysis.Collections.ByteSequenceComparer.Equals(System.Collections.Immutable.ImmutableArray<byte> x, System.Collections.Immutable.ImmutableArray<byte> y) -> bool
static Microsoft.CodeAnalysis.Collections.ByteSequenceComparer.Equals(byte[] left, byte[] right) -> bool
static Microsoft.CodeAnalysis.Collections.ByteSequenceComparer.Equals(byte[] left, int leftStart, byte[] right, int rightStart, int length) -> bool
static Microsoft.CodeAnalysis.Collections.ByteSequenceComparer.GetHashCode(System.Collections.Immutable.ImmutableArray<byte> x) -> int
static Microsoft.CodeAnalysis.Collections.ByteSequenceComparer.GetHashCode(byte[] x) -> int
static Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.CreatePool() -> Microsoft.CodeAnalysis.PooledObjects.ObjectPool<Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>>
static Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>.GetInstance() -> Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K, V>
static Microsoft.CodeAnalysis.ConsListExtensions.ContainsReference<T>(this Roslyn.Utilities.ConsList<T> list, T element) -> bool
static Microsoft.CodeAnalysis.ConsListExtensions.Prepend<T>(this Roslyn.Utilities.ConsList<T> list, T head) -> Roslyn.Utilities.ConsList<T>
static Microsoft.CodeAnalysis.Diagnostic.Create(Microsoft.CodeAnalysis.CommonMessageProvider messageProvider, int errorCode) -> Microsoft.CodeAnalysis.Diagnostic
static Microsoft.CodeAnalysis.Diagnostic.Create(Microsoft.CodeAnalysis.CommonMessageProvider messageProvider, int errorCode, params object[] arguments) -> Microsoft.CodeAnalysis.Diagnostic
static Microsoft.CodeAnalysis.Diagnostic.Create(Microsoft.CodeAnalysis.DiagnosticDescriptor descriptor, Microsoft.CodeAnalysis.Location location, Microsoft.CodeAnalysis.DiagnosticSeverity effectiveSeverity, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Location> additionalLocations, System.Collections.Immutable.ImmutableDictionary<string, string> properties, params object[] messageArgs) -> Microsoft.CodeAnalysis.Diagnostic
static Microsoft.CodeAnalysis.Diagnostic.Create(Microsoft.CodeAnalysis.DiagnosticDescriptor descriptor, Microsoft.CodeAnalysis.Location location, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Location> additionalLocations, System.Collections.Immutable.ImmutableDictionary<string, string> properties, params object[] messageArgs) -> Microsoft.CodeAnalysis.Diagnostic
static Microsoft.CodeAnalysis.Diagnostic.Create(Microsoft.CodeAnalysis.DiagnosticDescriptor descriptor, Microsoft.CodeAnalysis.Location location, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Location> additionalLocations, params object[] messageArgs) -> Microsoft.CodeAnalysis.Diagnostic
static Microsoft.CodeAnalysis.Diagnostic.Create(Microsoft.CodeAnalysis.DiagnosticDescriptor descriptor, Microsoft.CodeAnalysis.Location location, System.Collections.Immutable.ImmutableDictionary<string, string> properties, params object[] messageArgs) -> Microsoft.CodeAnalysis.Diagnostic
static Microsoft.CodeAnalysis.Diagnostic.Create(Microsoft.CodeAnalysis.DiagnosticDescriptor descriptor, Microsoft.CodeAnalysis.Location location, params object[] messageArgs) -> Microsoft.CodeAnalysis.Diagnostic
static Microsoft.CodeAnalysis.Diagnostic.Create(Microsoft.CodeAnalysis.DiagnosticInfo info) -> Microsoft.CodeAnalysis.Diagnostic
static Microsoft.CodeAnalysis.Diagnostic.Create(string id, string category, Microsoft.CodeAnalysis.LocalizableString message, Microsoft.CodeAnalysis.DiagnosticSeverity severity, Microsoft.CodeAnalysis.DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, int warningLevel, Microsoft.CodeAnalysis.LocalizableString title = null, Microsoft.CodeAnalysis.LocalizableString description = null, string helpLink = null, Microsoft.CodeAnalysis.Location location = null, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Location> additionalLocations = null, System.Collections.Generic.IEnumerable<string> customTags = null, System.Collections.Immutable.ImmutableDictionary<string, string> properties = null) -> Microsoft.CodeAnalysis.Diagnostic
static Microsoft.CodeAnalysis.Diagnostic.Create(string id, string category, Microsoft.CodeAnalysis.LocalizableString message, Microsoft.CodeAnalysis.DiagnosticSeverity severity, Microsoft.CodeAnalysis.DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, int warningLevel, bool isSuppressed, Microsoft.CodeAnalysis.LocalizableString title = null, Microsoft.CodeAnalysis.LocalizableString description = null, string helpLink = null, Microsoft.CodeAnalysis.Location location = null, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Location> additionalLocations = null, System.Collections.Generic.IEnumerable<string> customTags = null, System.Collections.Immutable.ImmutableDictionary<string, string> properties = null) -> Microsoft.CodeAnalysis.Diagnostic
static Microsoft.CodeAnalysis.Diagnostic.GetDefaultWarningLevel(Microsoft.CodeAnalysis.DiagnosticSeverity severity) -> int
static Microsoft.CodeAnalysis.Diagnostic.SimpleDiagnostic.Create(Microsoft.CodeAnalysis.DiagnosticDescriptor descriptor, Microsoft.CodeAnalysis.DiagnosticSeverity severity, int warningLevel, Microsoft.CodeAnalysis.Location location, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Location> additionalLocations, object[] messageArgs, System.Collections.Immutable.ImmutableDictionary<string, string> properties, bool isSuppressed = false) -> Microsoft.CodeAnalysis.Diagnostic.SimpleDiagnostic
static Microsoft.CodeAnalysis.Diagnostic.SimpleDiagnostic.Create(string id, Microsoft.CodeAnalysis.LocalizableString title, string category, Microsoft.CodeAnalysis.LocalizableString message, Microsoft.CodeAnalysis.LocalizableString description, string helpLink, Microsoft.CodeAnalysis.DiagnosticSeverity severity, Microsoft.CodeAnalysis.DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, int warningLevel, Microsoft.CodeAnalysis.Location location, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Location> additionalLocations, System.Collections.Generic.IEnumerable<string> customTags, System.Collections.Immutable.ImmutableDictionary<string, string> properties, bool isSuppressed = false) -> Microsoft.CodeAnalysis.Diagnostic.SimpleDiagnostic
static Microsoft.CodeAnalysis.DiagnosticBag.GetInstance() -> Microsoft.CodeAnalysis.DiagnosticBag
static Microsoft.CodeAnalysis.DiagnosticInfo.GetDescriptor(int errorCode, Microsoft.CodeAnalysis.CommonMessageProvider messageProvider) -> Microsoft.CodeAnalysis.DiagnosticDescriptor
static Microsoft.CodeAnalysis.EnumerableExtensions.AddAllValues<K, T>(this System.Collections.Generic.IDictionary<K, System.Collections.Immutable.ImmutableArray<T>> data, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T> builder) -> void
static Microsoft.CodeAnalysis.EnumerableExtensions.AsSingleton<TSource>(this System.Collections.Generic.IEnumerable<TSource> source) -> TSource
static Microsoft.CodeAnalysis.EnumerableExtensions.ToDictionary<K, T>(this System.Collections.Generic.IEnumerable<T> data, System.Func<T, K> keySelector, System.Collections.Generic.IEqualityComparer<K> comparer = null) -> System.Collections.Generic.Dictionary<K, System.Collections.Immutable.ImmutableArray<T>>
static Microsoft.CodeAnalysis.EnumerableExtensions.ToImmutableDictionaryOrEmpty<K, V>(this System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K, V>> items) -> System.Collections.Immutable.ImmutableDictionary<K, V>
static Microsoft.CodeAnalysis.EnumerableExtensions.ToImmutableDictionaryOrEmpty<K, V>(this System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K, V>> items, System.Collections.Generic.IEqualityComparer<K> keyComparer) -> System.Collections.Immutable.ImmutableDictionary<K, V>
static Microsoft.CodeAnalysis.EnumerableExtensions.Transpose<T>(this System.Collections.Generic.IEnumerable<System.Collections.Generic.IEnumerable<T>> data) -> System.Collections.Generic.IList<System.Collections.Generic.IList<T>>
static Microsoft.CodeAnalysis.FailFast.Assert(bool condition, string message = null) -> void
static Microsoft.CodeAnalysis.FailFast.OnFatalException(System.Exception exception) -> void
static Microsoft.CodeAnalysis.FatalError.Handler.get -> System.Action<System.Exception>
static Microsoft.CodeAnalysis.FatalError.Handler.set -> void
static Microsoft.CodeAnalysis.FatalError.NonFatalHandler.get -> System.Action<System.Exception>
static Microsoft.CodeAnalysis.FatalError.NonFatalHandler.set -> void
static Microsoft.CodeAnalysis.FatalError.OverwriteHandler(System.Action<System.Exception> value) -> void
static Microsoft.CodeAnalysis.FatalError.Report(System.Exception exception) -> bool
static Microsoft.CodeAnalysis.FatalError.ReportUnlessCanceled(System.Exception exception) -> bool
static Microsoft.CodeAnalysis.FatalError.ReportUnlessNotImplemented(System.Exception exception) -> bool
static Microsoft.CodeAnalysis.FatalError.ReportWithoutCrash(System.Exception exception) -> bool
static Microsoft.CodeAnalysis.FatalError.ReportWithoutCrashUnlessCanceled(System.Exception exception) -> bool
static Microsoft.CodeAnalysis.HashSetExtensions.InitializeAndAdd<T>(ref System.Collections.Generic.HashSet<T> hashSet, T item) -> bool
static Microsoft.CodeAnalysis.HashSetExtensions.IsNullOrEmpty<T>(this System.Collections.Generic.HashSet<T> hashSet) -> bool
static Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutable<T>(this System.Collections.Generic.IEnumerable<T> items) -> System.Collections.Immutable.ImmutableArray<T>
static Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutable<T>(this T[] items) -> System.Collections.Immutable.ImmutableArray<T>
static Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrEmpty<T>(this System.Collections.Generic.IEnumerable<T> items) -> System.Collections.Immutable.ImmutableArray<T>
static Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrEmpty<T>(this T[] items) -> System.Collections.Immutable.ImmutableArray<T>
static Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull<T>(this System.Collections.Generic.IEnumerable<T> items) -> System.Collections.Immutable.ImmutableArray<T>
static Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull<T>(this T[] items) -> System.Collections.Immutable.ImmutableArray<T>
static Microsoft.CodeAnalysis.ImmutableArrayExtensions.Cast<TDerived, TBase>(this System.Collections.Immutable.ImmutableArray<TDerived> items) -> System.Collections.Immutable.ImmutableArray<TBase>
static Microsoft.CodeAnalysis.ImmutableArrayExtensions.Concat<T>(this System.Collections.Immutable.ImmutableArray<T> first, System.Collections.Immutable.ImmutableArray<T> second) -> System.Collections.Immutable.ImmutableArray<T>
static Microsoft.CodeAnalysis.ImmutableArrayExtensions.Concat<T>(this System.Collections.Immutable.ImmutableArray<T> first, T second) -> System.Collections.Immutable.ImmutableArray<T>
static Microsoft.CodeAnalysis.ImmutableArrayExtensions.Count<T>(this System.Collections.Immutable.ImmutableArray<T> items, System.Func<T, bool> predicate) -> int
static Microsoft.CodeAnalysis.ImmutableArrayExtensions.DeOrder<T>(this System.Collections.Immutable.ImmutableArray<T> array) -> System.Collections.Immutable.ImmutableArray<T>
static Microsoft.CodeAnalysis.ImmutableArrayExtensions.Distinct<T>(this System.Collections.Immutable.ImmutableArray<T> array, System.Collections.Generic.IEqualityComparer<T> comparer = null) -> System.Collections.Immutable.ImmutableArray<T>
static Microsoft.CodeAnalysis.ImmutableArrayExtensions.Flatten<TKey, TValue>(this System.Collections.Generic.Dictionary<TKey, System.Collections.Immutable.ImmutableArray<TValue>> dictionary, System.Collections.Generic.IComparer<TValue> comparer = null) -> System.Collections.Immutable.ImmutableArray<TValue>
static Microsoft.CodeAnalysis.ImmutableArrayExtensions.HasAnyErrors<T>(this System.Collections.Immutable.ImmutableArray<T> diagnostics) -> bool
static Microsoft.CodeAnalysis.ImmutableArrayExtensions.HasDuplicates<T>(this System.Collections.Immutable.ImmutableArray<T> array, System.Collections.Generic.IEqualityComparer<T> comparer) -> bool
static Microsoft.CodeAnalysis.ImmutableArrayExtensions.NullToEmpty<T>(this System.Collections.Immutable.ImmutableArray<T> array) -> System.Collections.Immutable.ImmutableArray<T>
static Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray<TItem, TArg, TResult>(this System.Collections.Immutable.ImmutableArray<TItem> items, System.Func<TItem, TArg, TResult> map, TArg arg) -> System.Collections.Immutable.ImmutableArray<TResult>
static Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray<TItem, TArg, TResult>(this System.Collections.Immutable.ImmutableArray<TItem> items, System.Func<TItem, int, TArg, TResult> map, TArg arg) -> System.Collections.Immutable.ImmutableArray<TResult>
static Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray<TItem, TResult>(this System.Collections.Immutable.ImmutableArray<TItem> items, System.Func<TItem, TResult> map) -> System.Collections.Immutable.ImmutableArray<TResult>
static Microsoft.CodeAnalysis.ImmutableArrayExtensions.SetEquals<T>(this System.Collections.Immutable.ImmutableArray<T> array1, System.Collections.Immutable.ImmutableArray<T> array2, System.Collections.Generic.IEqualityComparer<T> comparer) -> bool
static Microsoft.CodeAnalysis.ImmutableArrayExtensions.ToDictionary<K, T>(this System.Collections.Immutable.ImmutableArray<T> items, System.Func<T, K> keySelector, System.Collections.Generic.IEqualityComparer<K> comparer = null) -> System.Collections.Generic.Dictionary<K, System.Collections.Immutable.ImmutableArray<T>>
static Microsoft.CodeAnalysis.ImmutableArrayExtensions.ToImmutable(this System.IO.MemoryStream stream) -> System.Collections.Immutable.ImmutableArray<byte>
static Microsoft.CodeAnalysis.ImmutableArrayExtensions.WhereAsArray<T>(this System.Collections.Immutable.ImmutableArray<T> array, System.Func<T, bool> predicate) -> System.Collections.Immutable.ImmutableArray<T>
static Microsoft.CodeAnalysis.ImmutableArrayExtensions.ZipAsArray<T1, T2, TResult>(this System.Collections.Immutable.ImmutableArray<T1> self, System.Collections.Immutable.ImmutableArray<T2> other, System.Func<T1, T2, TResult> map) -> System.Collections.Immutable.ImmutableArray<TResult>
static Microsoft.CodeAnalysis.LocalizableString.explicit operator string(Microsoft.CodeAnalysis.LocalizableString localizableResource) -> string
static Microsoft.CodeAnalysis.LocalizableString.implicit operator Microsoft.CodeAnalysis.LocalizableString(string fixedResource) -> Microsoft.CodeAnalysis.LocalizableString
static Microsoft.CodeAnalysis.Location.Create(string filePath, Microsoft.CodeAnalysis.Text.TextSpan textSpan, Microsoft.CodeAnalysis.Text.LinePositionSpan lineSpan) -> Microsoft.CodeAnalysis.Location
static Microsoft.CodeAnalysis.Location.None.get -> Microsoft.CodeAnalysis.Location
static Microsoft.CodeAnalysis.Location.operator !=(Microsoft.CodeAnalysis.Location left, Microsoft.CodeAnalysis.Location right) -> bool
static Microsoft.CodeAnalysis.Location.operator ==(Microsoft.CodeAnalysis.Location left, Microsoft.CodeAnalysis.Location right) -> bool
static Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.CreatePool() -> Microsoft.CodeAnalysis.PooledObjects.ObjectPool<Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>>
static Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.CreatePool(int size) -> Microsoft.CodeAnalysis.PooledObjects.ObjectPool<Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>>
static Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.GetInstance() -> Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>
static Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.GetInstance(int capacity) -> Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>
static Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>.GetInstance(int capacity, T fillWithValue) -> Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<T>
static Microsoft.CodeAnalysis.PooledObjects.PooledDictionary<K, V>.CreatePool() -> Microsoft.CodeAnalysis.PooledObjects.ObjectPool<Microsoft.CodeAnalysis.PooledObjects.PooledDictionary<K, V>>
static Microsoft.CodeAnalysis.PooledObjects.PooledDictionary<K, V>.GetInstance() -> Microsoft.CodeAnalysis.PooledObjects.PooledDictionary<K, V>
static Microsoft.CodeAnalysis.PooledObjects.PooledHashSet<T>.CreatePool() -> Microsoft.CodeAnalysis.PooledObjects.ObjectPool<Microsoft.CodeAnalysis.PooledObjects.PooledHashSet<T>>
static Microsoft.CodeAnalysis.PooledObjects.PooledHashSet<T>.GetInstance() -> Microsoft.CodeAnalysis.PooledObjects.PooledHashSet<T>
static Microsoft.CodeAnalysis.PooledObjects.PooledStopwatch.CreatePool() -> Microsoft.CodeAnalysis.PooledObjects.ObjectPool<Microsoft.CodeAnalysis.PooledObjects.PooledStopwatch>
static Microsoft.CodeAnalysis.PooledObjects.PooledStopwatch.StartInstance() -> Microsoft.CodeAnalysis.PooledObjects.PooledStopwatch
static Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder.CreatePool(int size = 32) -> Microsoft.CodeAnalysis.PooledObjects.ObjectPool<Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder>
static Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder.GetInstance() -> Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder
static Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder.implicit operator System.Text.StringBuilder(Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder obj) -> System.Text.StringBuilder
static Microsoft.CodeAnalysis.StackGuard.EnsureSufficientExecutionStack(int recursionDepth) -> void
static Microsoft.CodeAnalysis.StackGuard.IsInsufficientExecutionStackException(System.Exception ex) -> bool
static Microsoft.CodeAnalysis.StaticCast<T>.From<TDerived>(System.Collections.Immutable.ImmutableArray<TDerived> from) -> System.Collections.Immutable.ImmutableArray<T>
static Microsoft.CodeAnalysis.Text.CompositeText.AddSegments(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<Microsoft.CodeAnalysis.Text.SourceText> segments, Microsoft.CodeAnalysis.Text.SourceText text) -> void
static Microsoft.CodeAnalysis.Text.CompositeText.ToSourceTextAndFree(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<Microsoft.CodeAnalysis.Text.SourceText> segments, Microsoft.CodeAnalysis.Text.SourceText original, bool adjustSegments) -> Microsoft.CodeAnalysis.Text.SourceText
static Microsoft.CodeAnalysis.Text.LargeText.Decode(System.IO.Stream stream, System.Text.Encoding encoding, Microsoft.CodeAnalysis.Text.SourceHashAlgorithm checksumAlgorithm, bool throwIfBinaryDetected, bool canBeEmbedded) -> Microsoft.CodeAnalysis.Text.SourceText
static Microsoft.CodeAnalysis.Text.LargeText.Decode(System.IO.TextReader reader, int length, System.Text.Encoding encodingOpt, Microsoft.CodeAnalysis.Text.SourceHashAlgorithm checksumAlgorithm) -> Microsoft.CodeAnalysis.Text.SourceText
static Microsoft.CodeAnalysis.Text.LinePosition.Zero.get -> Microsoft.CodeAnalysis.Text.LinePosition
static Microsoft.CodeAnalysis.Text.LinePosition.operator !=(Microsoft.CodeAnalysis.Text.LinePosition left, Microsoft.CodeAnalysis.Text.LinePosition right) -> bool
static Microsoft.CodeAnalysis.Text.LinePosition.operator <(Microsoft.CodeAnalysis.Text.LinePosition left, Microsoft.CodeAnalysis.Text.LinePosition right) -> bool
static Microsoft.CodeAnalysis.Text.LinePosition.operator <=(Microsoft.CodeAnalysis.Text.LinePosition left, Microsoft.CodeAnalysis.Text.LinePosition right) -> bool
static Microsoft.CodeAnalysis.Text.LinePosition.operator ==(Microsoft.CodeAnalysis.Text.LinePosition left, Microsoft.CodeAnalysis.Text.LinePosition right) -> bool
static Microsoft.CodeAnalysis.Text.LinePosition.operator >(Microsoft.CodeAnalysis.Text.LinePosition left, Microsoft.CodeAnalysis.Text.LinePosition right) -> bool
static Microsoft.CodeAnalysis.Text.LinePosition.operator >=(Microsoft.CodeAnalysis.Text.LinePosition left, Microsoft.CodeAnalysis.Text.LinePosition right) -> bool
static Microsoft.CodeAnalysis.Text.LinePositionSpan.operator !=(Microsoft.CodeAnalysis.Text.LinePositionSpan left, Microsoft.CodeAnalysis.Text.LinePositionSpan right) -> bool
static Microsoft.CodeAnalysis.Text.LinePositionSpan.operator ==(Microsoft.CodeAnalysis.Text.LinePositionSpan left, Microsoft.CodeAnalysis.Text.LinePositionSpan right) -> bool
static Microsoft.CodeAnalysis.Text.SlidingTextWindow.GetCharsFromUtf32(uint codepoint, out char lowSurrogate) -> char
static Microsoft.CodeAnalysis.Text.SourceText.From(System.IO.Stream stream, System.Text.Encoding encoding = null, Microsoft.CodeAnalysis.Text.SourceHashAlgorithm checksumAlgorithm = Microsoft.CodeAnalysis.Text.SourceHashAlgorithm.Sha1, bool throwIfBinaryDetected = false, bool canBeEmbedded = false) -> Microsoft.CodeAnalysis.Text.SourceText
static Microsoft.CodeAnalysis.Text.SourceText.From(System.IO.Stream stream, System.Text.Encoding encoding, Microsoft.CodeAnalysis.Text.SourceHashAlgorithm checksumAlgorithm, bool throwIfBinaryDetected) -> Microsoft.CodeAnalysis.Text.SourceText
static Microsoft.CodeAnalysis.Text.SourceText.From(System.IO.TextReader reader, System.Text.Encoding encoding = null, Microsoft.CodeAnalysis.Text.SourceHashAlgorithm checksumAlgorithm = Microsoft.CodeAnalysis.Text.SourceHashAlgorithm.Sha1) -> Microsoft.CodeAnalysis.Text.SourceText
static Microsoft.CodeAnalysis.Text.SourceText.From(System.IO.TextReader reader, int length, System.Text.Encoding encoding = null, Microsoft.CodeAnalysis.Text.SourceHashAlgorithm checksumAlgorithm = Microsoft.CodeAnalysis.Text.SourceHashAlgorithm.Sha1) -> Microsoft.CodeAnalysis.Text.SourceText
static Microsoft.CodeAnalysis.Text.SourceText.From(byte[] buffer, int length, System.Text.Encoding encoding = null, Microsoft.CodeAnalysis.Text.SourceHashAlgorithm checksumAlgorithm = Microsoft.CodeAnalysis.Text.SourceHashAlgorithm.Sha1, bool throwIfBinaryDetected = false, bool canBeEmbedded = false) -> Microsoft.CodeAnalysis.Text.SourceText
static Microsoft.CodeAnalysis.Text.SourceText.From(byte[] buffer, int length, System.Text.Encoding encoding, Microsoft.CodeAnalysis.Text.SourceHashAlgorithm checksumAlgorithm, bool throwIfBinaryDetected) -> Microsoft.CodeAnalysis.Text.SourceText
static Microsoft.CodeAnalysis.Text.SourceText.From(string text, System.Text.Encoding encoding = null, Microsoft.CodeAnalysis.Text.SourceHashAlgorithm checksumAlgorithm = Microsoft.CodeAnalysis.Text.SourceHashAlgorithm.Sha1) -> Microsoft.CodeAnalysis.Text.SourceText
static Microsoft.CodeAnalysis.Text.SourceTextComparer.Instance -> Microsoft.CodeAnalysis.Text.SourceTextComparer
static Microsoft.CodeAnalysis.Text.SourceTextWriter.Create(System.Text.Encoding encoding, Microsoft.CodeAnalysis.Text.SourceHashAlgorithm checksumAlgorithm, int length) -> Microsoft.CodeAnalysis.Text.SourceTextWriter
static Microsoft.CodeAnalysis.Text.TextChange.NoChanges.get -> System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.Text.TextChange>
static Microsoft.CodeAnalysis.Text.TextChange.implicit operator Microsoft.CodeAnalysis.Text.TextChangeRange(Microsoft.CodeAnalysis.Text.TextChange change) -> Microsoft.CodeAnalysis.Text.TextChangeRange
static Microsoft.CodeAnalysis.Text.TextChange.operator !=(Microsoft.CodeAnalysis.Text.TextChange left, Microsoft.CodeAnalysis.Text.TextChange right) -> bool
static Microsoft.CodeAnalysis.Text.TextChange.operator ==(Microsoft.CodeAnalysis.Text.TextChange left, Microsoft.CodeAnalysis.Text.TextChange right) -> bool
static Microsoft.CodeAnalysis.Text.TextChangeRange.Collapse(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Text.TextChangeRange> changes) -> Microsoft.CodeAnalysis.Text.TextChangeRange
static Microsoft.CodeAnalysis.Text.TextChangeRange.NoChanges.get -> System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.Text.TextChangeRange>
static Microsoft.CodeAnalysis.Text.TextChangeRange.operator !=(Microsoft.CodeAnalysis.Text.TextChangeRange left, Microsoft.CodeAnalysis.Text.TextChangeRange right) -> bool
static Microsoft.CodeAnalysis.Text.TextChangeRange.operator ==(Microsoft.CodeAnalysis.Text.TextChangeRange left, Microsoft.CodeAnalysis.Text.TextChangeRange right) -> bool
static Microsoft.CodeAnalysis.Text.TextLine.FromSpan(Microsoft.CodeAnalysis.Text.SourceText text, Microsoft.CodeAnalysis.Text.TextSpan span) -> Microsoft.CodeAnalysis.Text.TextLine
static Microsoft.CodeAnalysis.Text.TextLine.operator !=(Microsoft.CodeAnalysis.Text.TextLine left, Microsoft.CodeAnalysis.Text.TextLine right) -> bool
static Microsoft.CodeAnalysis.Text.TextLine.operator ==(Microsoft.CodeAnalysis.Text.TextLine left, Microsoft.CodeAnalysis.Text.TextLine right) -> bool
static Microsoft.CodeAnalysis.Text.TextSpan.FromBounds(int start, int end) -> Microsoft.CodeAnalysis.Text.TextSpan
static Microsoft.CodeAnalysis.Text.TextSpan.operator !=(Microsoft.CodeAnalysis.Text.TextSpan left, Microsoft.CodeAnalysis.Text.TextSpan right) -> bool
static Microsoft.CodeAnalysis.Text.TextSpan.operator ==(Microsoft.CodeAnalysis.Text.TextSpan left, Microsoft.CodeAnalysis.Text.TextSpan right) -> bool
static Microsoft.CodeAnalysis.Text.TextUtilities.GetLengthOfLineBreak(Microsoft.CodeAnalysis.Text.SourceText text, int index) -> int
static Microsoft.CodeAnalysis.Text.TextUtilities.GetStartAndLengthOfLineBreakEndingAt(Microsoft.CodeAnalysis.Text.SourceText text, int index, out int startLinebreak, out int lengthLinebreak) -> void
static Microsoft.CodeAnalysis.Text.TextUtilities.IsAnyLineBreakCharacter(char c) -> bool
static Microsoft.CodeAnalysis.ThreeStateHelpers.HasValue(this Microsoft.CodeAnalysis.ThreeState value) -> bool
static Microsoft.CodeAnalysis.ThreeStateHelpers.ToThreeState(this bool value) -> Microsoft.CodeAnalysis.ThreeState
static Microsoft.CodeAnalysis.ThreeStateHelpers.Value(this Microsoft.CodeAnalysis.ThreeState value) -> bool
static Microsoft.CodeAnalysis.UnionCollection<T>.Create(System.Collections.Generic.ICollection<T> coll1, System.Collections.Generic.ICollection<T> coll2) -> System.Collections.Generic.ICollection<T>
static Microsoft.CodeAnalysis.UnionCollection<T>.Create<TOrig>(System.Collections.Immutable.ImmutableArray<TOrig> collections, System.Func<TOrig, System.Collections.Generic.ICollection<T>> selector) -> System.Collections.Generic.ICollection<T>
static Roslyn.Utilities.ArrayExtensions.Append<T>(this T[] array, T item) -> T[]
static Roslyn.Utilities.ArrayExtensions.Append<T>(this T[] array, T[] items) -> T[]
static Roslyn.Utilities.ArrayExtensions.BinarySearch(this int[] array, int value) -> int
static Roslyn.Utilities.ArrayExtensions.BinarySearchUpperBound(this int[] array, int value) -> int
static Roslyn.Utilities.ArrayExtensions.Copy<T>(this T[] array, int start, int length) -> T[]
static Roslyn.Utilities.ArrayExtensions.InsertAt<T>(this T[] array, int position, T item) -> T[]
static Roslyn.Utilities.ArrayExtensions.InsertAt<T>(this T[] array, int position, T[] items) -> T[]
static Roslyn.Utilities.ArrayExtensions.RemoveAt<T>(this T[] array, int position) -> T[]
static Roslyn.Utilities.ArrayExtensions.RemoveAt<T>(this T[] array, int position, int length) -> T[]
static Roslyn.Utilities.ArrayExtensions.ReplaceAt<T>(this T[] array, int position, T item) -> T[]
static Roslyn.Utilities.ArrayExtensions.ReplaceAt<T>(this T[] array, int position, int length, T[] items) -> T[]
static Roslyn.Utilities.ArrayExtensions.ReverseContents<T>(this T[] array) -> void
static Roslyn.Utilities.ArrayExtensions.ReverseContents<T>(this T[] array, int start, int count) -> void
static Roslyn.Utilities.ArrayExtensions.ValueEquals(this uint[] array, uint[] other) -> bool
static Roslyn.Utilities.BitArithmeticUtilities.Align(int position, int alignment) -> int
static Roslyn.Utilities.BitArithmeticUtilities.Align(uint position, uint alignment) -> uint
static Roslyn.Utilities.BitArithmeticUtilities.CountBits(int v) -> int
static Roslyn.Utilities.BitArithmeticUtilities.CountBits(long v) -> int
static Roslyn.Utilities.BitArithmeticUtilities.CountBits(uint v) -> int
static Roslyn.Utilities.BitArithmeticUtilities.CountBits(ulong v) -> int
static Roslyn.Utilities.BlobBuildingStream.GetInstance() -> Roslyn.Utilities.BlobBuildingStream
static Roslyn.Utilities.CharFacts.IsIdentifierPartCharacter(char ch) -> bool
static Roslyn.Utilities.CharFacts.IsIdentifierStartCharacter(char ch) -> bool
static Roslyn.Utilities.CharFacts.IsNewLine(char ch) -> bool
static Roslyn.Utilities.CharFacts.IsValidIdentifier(string name) -> bool
static Roslyn.Utilities.CharFacts.IsWhitespace(char ch) -> bool
static Roslyn.Utilities.CodeAnalysisResources.AbsolutePathExpected.get -> string
static Roslyn.Utilities.CodeAnalysisResources.AnalyzerDriverFailure.get -> string
static Roslyn.Utilities.CodeAnalysisResources.AnalyzerDriverThrows.get -> string
static Roslyn.Utilities.CodeAnalysisResources.AnalyzerDriverThrowsDescription.get -> string
static Roslyn.Utilities.CodeAnalysisResources.AnalyzerExecutionTimeColumnHeader.get -> string
static Roslyn.Utilities.CodeAnalysisResources.AnalyzerNameColumnHeader.get -> string
static Roslyn.Utilities.CodeAnalysisResources.AnalyzerTotalExecutionTime.get -> string
static Roslyn.Utilities.CodeAnalysisResources.AnonymousTypeArgumentCountMismatch2.get -> string
static Roslyn.Utilities.CodeAnalysisResources.AnonymousTypeMemberAndNamesCountMismatch2.get -> string
static Roslyn.Utilities.CodeAnalysisResources.ArgumentCannotBeEmpty.get -> string
static Roslyn.Utilities.CodeAnalysisResources.ArgumentElementCannotBeNull.get -> string
static Roslyn.Utilities.CodeAnalysisResources.Arrays_with_more_than_one_dimension_cannot_be_serialized.get -> string
static Roslyn.Utilities.CodeAnalysisResources.Assembly.get -> string
static Roslyn.Utilities.CodeAnalysisResources.AssemblyFileNotFound.get -> string
static Roslyn.Utilities.CodeAnalysisResources.AssemblyMustHaveAtLeastOneModule.get -> string
static Roslyn.Utilities.CodeAnalysisResources.AssemblySigningNotSupported.get -> string
static Roslyn.Utilities.CodeAnalysisResources.AsyncAnalyzerActionCannotBeRegistered.get -> string
static Roslyn.Utilities.CodeAnalysisResources.CannotAliasModule.get -> string
static Roslyn.Utilities.CodeAnalysisResources.CannotCreateReferenceToModule.get -> string
static Roslyn.Utilities.CodeAnalysisResources.CannotCreateReferenceToSubmission.get -> string
static Roslyn.Utilities.CodeAnalysisResources.CannotEmbedInteropTypesFromModule.get -> string
static Roslyn.Utilities.CodeAnalysisResources.CannotTargetNetModuleWhenEmittingRefAssembly.get -> string
static Roslyn.Utilities.CodeAnalysisResources.Cannot_deserialize_type_0.get -> string
static Roslyn.Utilities.CodeAnalysisResources.Cannot_serialize_type_0.get -> string
static Roslyn.Utilities.CodeAnalysisResources.CantCreateModuleReferenceToAssembly.get -> string
static Roslyn.Utilities.CodeAnalysisResources.CantCreateReferenceToAssemblyWithoutLocation.get -> string
static Roslyn.Utilities.CodeAnalysisResources.CantCreateReferenceToDynamicAssembly.get -> string
static Roslyn.Utilities.CodeAnalysisResources.ChangesMustBeOrderedAndNotOverlapping.get -> string
static Roslyn.Utilities.CodeAnalysisResources.Class1.get -> string
static Roslyn.Utilities.CodeAnalysisResources.CoffResourceInvalidRelocation.get -> string
static Roslyn.Utilities.CodeAnalysisResources.CoffResourceInvalidSectionSize.get -> string
static Roslyn.Utilities.CodeAnalysisResources.CoffResourceInvalidSymbol.get -> string
static Roslyn.Utilities.CodeAnalysisResources.CoffResourceMissingSection.get -> string
static Roslyn.Utilities.CodeAnalysisResources.CompilationOptionsMustNotHaveErrors.get -> string
static Roslyn.Utilities.CodeAnalysisResources.CompilationReferencesAssembliesWithDifferentAutoGeneratedVersion.get -> string
static Roslyn.Utilities.CodeAnalysisResources.CompilerAnalyzerFailure.get -> string
static Roslyn.Utilities.CodeAnalysisResources.CompilerAnalyzerThrows.get -> string
static Roslyn.Utilities.CodeAnalysisResources.CompilerAnalyzerThrowsDescription.get -> string
static Roslyn.Utilities.CodeAnalysisResources.CompilerDiagnosticIdReported.get -> string
static Roslyn.Utilities.CodeAnalysisResources.Constructor.get -> string
static Roslyn.Utilities.CodeAnalysisResources.Culture.get -> System.Globalization.CultureInfo
static Roslyn.Utilities.CodeAnalysisResources.Culture.set -> void
static Roslyn.Utilities.CodeAnalysisResources.Delegate1.get -> string
static Roslyn.Utilities.CodeAnalysisResources.Deserialization_reader_for_0_read_incorrect_number_of_values.get -> string
static Roslyn.Utilities.CodeAnalysisResources.DiagnosticIdCantBeNullOrWhitespace.get -> string
static Roslyn.Utilities.CodeAnalysisResources.DuplicateAnalyzerInstances.get -> string
static Roslyn.Utilities.CodeAnalysisResources.ElementIsExpected.get -> string
static Roslyn.Utilities.CodeAnalysisResources.EmbeddedTextsRequirePdb.get -> string
static Roslyn.Utilities.CodeAnalysisResources.EmbeddingPdbUnexpectedWhenEmittingMetadata.get -> string
static Roslyn.Utilities.CodeAnalysisResources.EmptyKeyInPathMap.get -> string
static Roslyn.Utilities.CodeAnalysisResources.EmptyOrInvalidFileName.get -> string
static Roslyn.Utilities.CodeAnalysisResources.EmptyOrInvalidResourceName.get -> string
static Roslyn.Utilities.CodeAnalysisResources.EndMustNotBeLessThanStart.get -> string
static Roslyn.Utilities.CodeAnalysisResources.Enum1.get -> string
static Roslyn.Utilities.CodeAnalysisResources.Event1.get -> string
static Roslyn.Utilities.CodeAnalysisResources.ExceptionContext.get -> string
static Roslyn.Utilities.CodeAnalysisResources.ExceptionEnablingMulticoreJit.get -> string
static Roslyn.Utilities.CodeAnalysisResources.ExpectedNonEmptyPublicKey.get -> string
static Roslyn.Utilities.CodeAnalysisResources.FailedToResolveRuleSetName.get -> string
static Roslyn.Utilities.CodeAnalysisResources.Field.get -> string
static Roslyn.Utilities.CodeAnalysisResources.FileNotFound.get -> string
static Roslyn.Utilities.CodeAnalysisResources.FileSizeExceedsMaximumAllowed.get -> string
static Roslyn.Utilities.CodeAnalysisResources.GetMetadataMustReturnInstance.get -> string
static Roslyn.Utilities.CodeAnalysisResources.IconStreamUnexpectedFormat.get -> string
static Roslyn.Utilities.CodeAnalysisResources.InMemoryAssembly.get -> string
static Roslyn.Utilities.CodeAnalysisResources.InMemoryModule.get -> string
static Roslyn.Utilities.CodeAnalysisResources.IncludingPrivateMembersUnexpectedWhenEmittingToMetadataPeStream.get -> string
static Roslyn.Utilities.CodeAnalysisResources.InconsistentLanguageVersions.get -> string
static Roslyn.Utilities.CodeAnalysisResources.InconsistentSyntaxTreeFeature.get -> string
static Roslyn.Utilities.CodeAnalysisResources.Interface1.get -> string
static Roslyn.Utilities.CodeAnalysisResources.InvalidAlias.get -> string
static Roslyn.Utilities.CodeAnalysisResources.InvalidAssemblyName.get -> string
static Roslyn.Utilities.CodeAnalysisResources.InvalidCharactersInAssemblyCultureName.get -> string
static Roslyn.Utilities.CodeAnalysisResources.InvalidCharactersInAssemblyName.get -> string
static Roslyn.Utilities.CodeAnalysisResources.InvalidCompilationOptions.get -> string
static Roslyn.Utilities.CodeAnalysisResources.InvalidContentType.get -> string
static Roslyn.Utilities.CodeAnalysisResources.InvalidCultureName.get -> string
static Roslyn.Utilities.CodeAnalysisResources.InvalidDataAtOffset.get -> string
static Roslyn.Utilities.CodeAnalysisResources.InvalidDiagnosticIdReported.get -> string
static Roslyn.Utilities.CodeAnalysisResources.InvalidDiagnosticLocationReported.get -> string
static Roslyn.Utilities.CodeAnalysisResources.InvalidDiagnosticSpanReported.get -> string
static Roslyn.Utilities.CodeAnalysisResources.InvalidHash.get -> string
static Roslyn.Utilities.CodeAnalysisResources.InvalidModuleName.get -> string
static Roslyn.Utilities.CodeAnalysisResources.InvalidNodeToTrack.get -> string
static Roslyn.Utilities.CodeAnalysisResources.InvalidOutputKindForSubmission.get -> string
static Roslyn.Utilities.CodeAnalysisResources.InvalidPublicKey.get -> string
static Roslyn.Utilities.CodeAnalysisResources.InvalidPublicKeyToken.get -> string
static Roslyn.Utilities.CodeAnalysisResources.InvalidRuleSetInclude.get -> string
static Roslyn.Utilities.CodeAnalysisResources.InvalidSizeOfPublicKeyToken.get -> string
static Roslyn.Utilities.CodeAnalysisResources.InvalidTree.get -> string
static Roslyn.Utilities.CodeAnalysisResources.KeepAliveIsNotAnInteger.get -> string
static Roslyn.Utilities.CodeAnalysisResources.KeepAliveIsTooSmall.get -> string
static Roslyn.Utilities.CodeAnalysisResources.KeepAliveWithoutShared.get -> string
static Roslyn.Utilities.CodeAnalysisResources.MetadataPeStreamUnexpectedWhenEmittingMetadataOnly.get -> string
static Roslyn.Utilities.CodeAnalysisResources.MetadataRefNotFoundToRemove1.get -> string
static Roslyn.Utilities.CodeAnalysisResources.Method.get -> string
static Roslyn.Utilities.CodeAnalysisResources.MismatchedVersion.get -> string
static Roslyn.Utilities.CodeAnalysisResources.MissingKeepAlive.get -> string
static Roslyn.Utilities.CodeAnalysisResources.MissingListItem.get -> string
static Roslyn.Utilities.CodeAnalysisResources.Module.get -> string
static Roslyn.Utilities.CodeAnalysisResources.ModuleCopyCannotBeUsedToCreateAssemblyMetadata.get -> string
static Roslyn.Utilities.CodeAnalysisResources.MultithreadedAnalyzerExecutionNote.get -> string
static Roslyn.Utilities.CodeAnalysisResources.MustIncludePrivateMembersUnlessRefAssembly.get -> string
static Roslyn.Utilities.CodeAnalysisResources.NameCannotBeEmpty.get -> string
static Roslyn.Utilities.CodeAnalysisResources.NameCannotBeNull.get -> string
static Roslyn.Utilities.CodeAnalysisResources.NameCannotStartWithWhitespace.get -> string
static Roslyn.Utilities.CodeAnalysisResources.NameContainsInvalidCharacter.get -> string
static Roslyn.Utilities.CodeAnalysisResources.NoAnalyzersFound.get -> string
static Roslyn.Utilities.CodeAnalysisResources.NodeOrTokenOutOfSequence.get -> string
static Roslyn.Utilities.CodeAnalysisResources.NullValueInPathMap.get -> string
static Roslyn.Utilities.CodeAnalysisResources.OutputKindNotSupported.get -> string
static Roslyn.Utilities.CodeAnalysisResources.PEImageDoesntContainManagedMetadata.get -> string
static Roslyn.Utilities.CodeAnalysisResources.PEImageNotAvailable.get -> string
static Roslyn.Utilities.CodeAnalysisResources.Parameter.get -> string
static Roslyn.Utilities.CodeAnalysisResources.PathReturnedByResolveMetadataFileMustBeAbsolute.get -> string
static Roslyn.Utilities.CodeAnalysisResources.PathReturnedByResolveStrongNameKeyFileMustBeAbsolute.get -> string
static Roslyn.Utilities.CodeAnalysisResources.PdbStreamUnexpectedWhenEmbedding.get -> string
static Roslyn.Utilities.CodeAnalysisResources.PdbStreamUnexpectedWhenEmittingMetadataOnly.get -> string
static Roslyn.Utilities.CodeAnalysisResources.PreviousSubmissionHasErrors.get -> string
static Roslyn.Utilities.CodeAnalysisResources.Property.get -> string
static Roslyn.Utilities.CodeAnalysisResources.ReferenceOfTypeIsInvalid1.get -> string
static Roslyn.Utilities.CodeAnalysisResources.ReferenceResolverShouldReturnReadableNonNullStream.get -> string
static Roslyn.Utilities.CodeAnalysisResources.ResourceDataProviderShouldReturnNonNullStream.get -> string
static Roslyn.Utilities.CodeAnalysisResources.ResourceManager.get -> System.Resources.ResourceManager
static Roslyn.Utilities.CodeAnalysisResources.ResourceStreamEndedUnexpectedly.get -> string
static Roslyn.Utilities.CodeAnalysisResources.ResourceStreamProviderShouldReturnNonNullStream.get -> string
static Roslyn.Utilities.CodeAnalysisResources.Return1.get -> string
static Roslyn.Utilities.CodeAnalysisResources.ReturnTypeCannotBeValuePointerbyRefOrOpen.get -> string
static Roslyn.Utilities.CodeAnalysisResources.ReturnTypeCannotBeVoidByRefOrOpen.get -> string
static Roslyn.Utilities.CodeAnalysisResources.RuleSetBadAttributeValue.get -> string
static Roslyn.Utilities.CodeAnalysisResources.RuleSetHasDuplicateRules.get -> string
static Roslyn.Utilities.CodeAnalysisResources.RuleSetMissingAttribute.get -> string
static Roslyn.Utilities.CodeAnalysisResources.SeparatorIsExpected.get -> string
static Roslyn.Utilities.CodeAnalysisResources.SharedArgumentMissing.get -> string
static Roslyn.Utilities.CodeAnalysisResources.SizeHasToBePositive.get -> string
static Roslyn.Utilities.CodeAnalysisResources.SourceTextCannotBeEmbedded.get -> string
static Roslyn.Utilities.CodeAnalysisResources.SpanDoesNotIncludeEndOfLine.get -> string
static Roslyn.Utilities.CodeAnalysisResources.SpanDoesNotIncludeStartOfLine.get -> string
static Roslyn.Utilities.CodeAnalysisResources.StartMustNotBeNegative.get -> string
static Roslyn.Utilities.CodeAnalysisResources.StreamIsTooLong.get -> string
static Roslyn.Utilities.CodeAnalysisResources.StreamMustSupportRead.get -> string
static Roslyn.Utilities.CodeAnalysisResources.StreamMustSupportReadAndSeek.get -> string
static Roslyn.Utilities.CodeAnalysisResources.StreamMustSupportWrite.get -> string
static Roslyn.Utilities.CodeAnalysisResources.Stream_contains_invalid_data.get -> string
static Roslyn.Utilities.CodeAnalysisResources.Struct1.get -> string
static Roslyn.Utilities.CodeAnalysisResources.SymWriterDoesNotSupportSourceLink.get -> string
static Roslyn.Utilities.CodeAnalysisResources.SymWriterNotDeterministic.get -> string
static Roslyn.Utilities.CodeAnalysisResources.SymWriterOlderVersionThanRequired.get -> string
static Roslyn.Utilities.CodeAnalysisResources.TheStreamCannotBeReadFrom.get -> string
static Roslyn.Utilities.CodeAnalysisResources.TheStreamCannotBeWrittenTo.get -> string
static Roslyn.Utilities.CodeAnalysisResources.The_type_0_is_not_understood_by_the_serialization_binder.get -> string
static Roslyn.Utilities.CodeAnalysisResources.TupleElementLocationCountMismatch.get -> string
static Roslyn.Utilities.CodeAnalysisResources.TupleElementNameCountMismatch.get -> string
static Roslyn.Utilities.CodeAnalysisResources.TupleElementNameEmpty.get -> string
static Roslyn.Utilities.CodeAnalysisResources.TupleUnderlyingTypeMustBeTupleCompatible.get -> string
static Roslyn.Utilities.CodeAnalysisResources.TuplesNeedAtLeastTwoElements.get -> string
static Roslyn.Utilities.CodeAnalysisResources.TypeMustBeASubclassOfSyntaxAnnotation.get -> string
static Roslyn.Utilities.CodeAnalysisResources.TypeMustBeSameAsHostObjectTypeOfPreviousSubmission.get -> string
static Roslyn.Utilities.CodeAnalysisResources.TypeParameter.get -> string
static Roslyn.Utilities.CodeAnalysisResources.UnexpectedTypeOfNodeInList.get -> string
static Roslyn.Utilities.CodeAnalysisResources.UnrecognizedResourceFileFormat.get -> string
static Roslyn.Utilities.CodeAnalysisResources.Unresolved.get -> string
static Roslyn.Utilities.CodeAnalysisResources.UnsupportedAnalyzerInstance.get -> string
static Roslyn.Utilities.CodeAnalysisResources.UnsupportedDiagnosticReported.get -> string
static Roslyn.Utilities.CodeAnalysisResources.UnsupportedHashAlgorithm.get -> string
static Roslyn.Utilities.CodeAnalysisResources.Value_too_large_to_be_represented_as_a_30_bit_unsigned_integer.get -> string
static Roslyn.Utilities.CodeAnalysisResources.WinRTIdentityCantBeRetargetable.get -> string
static Roslyn.Utilities.CodeAnalysisResources.XmlReferencesNotSupported.get -> string
static Roslyn.Utilities.CommandLineUtilities.SplitCommandLineIntoArguments(string commandLine, bool removeHashComments) -> System.Collections.Generic.IEnumerable<string>
static Roslyn.Utilities.CommandLineUtilities.SplitCommandLineIntoArguments(string commandLine, bool removeHashComments, out char? illegalChar) -> System.Collections.Generic.IEnumerable<string>
static Roslyn.Utilities.CompilerOptionParseUtilities.ParseFeatureFromMSBuild(string features) -> System.Collections.Generic.IList<string>
static Roslyn.Utilities.CompilerOptionParseUtilities.ParseFeatures(System.Collections.Generic.IDictionary<string, string> builder, System.Collections.Generic.List<string> values) -> void
static Roslyn.Utilities.ConcurrentDictionaryExtensions.Add<K, V>(this System.Collections.Concurrent.ConcurrentDictionary<K, V> dict, K key, V value) -> void
static Roslyn.Utilities.DecimalUtilities.GetBits(this decimal value, out bool isNegative, out byte scale, out uint low, out uint mid, out uint high) -> void
static Roslyn.Utilities.DecimalUtilities.GetScale(this decimal value) -> int
static Roslyn.Utilities.EncodingExtensions.GetMaxCharCountOrThrowIfHuge(this System.Text.Encoding encoding, System.IO.Stream stream) -> int
static Roslyn.Utilities.EncodingExtensions.TryGetMaxCharCount(this System.Text.Encoding encoding, long length, out int maxCharCount) -> bool
static Roslyn.Utilities.EnumerableExtensions.All(this System.Collections.Generic.IEnumerable<bool> source) -> bool
static Roslyn.Utilities.EnumerableExtensions.Concat<T>(this System.Collections.Generic.IEnumerable<T> source, T value) -> System.Collections.Generic.IEnumerable<T>
static Roslyn.Utilities.EnumerableExtensions.Contains(this System.Collections.Generic.IEnumerable<string> sequence, string s) -> bool
static Roslyn.Utilities.EnumerableExtensions.Contains<T>(this System.Collections.Generic.IEnumerable<T> sequence, System.Func<T, bool> predicate) -> bool
static Roslyn.Utilities.EnumerableExtensions.Do<T>(this System.Collections.Generic.IEnumerable<T> source, System.Action<T> action) -> System.Collections.Generic.IEnumerable<T>
static Roslyn.Utilities.EnumerableExtensions.FirstOrNullable<T>(this System.Collections.Generic.IEnumerable<T> source) -> T?
static Roslyn.Utilities.EnumerableExtensions.FirstOrNullable<T>(this System.Collections.Generic.IEnumerable<T> source, System.Func<T, bool> predicate) -> T?
static Roslyn.Utilities.EnumerableExtensions.Flatten<T>(this System.Collections.Generic.IEnumerable<System.Collections.Generic.IEnumerable<T>> sequence) -> System.Collections.Generic.IEnumerable<T>
static Roslyn.Utilities.EnumerableExtensions.IsEmpty(this string source) -> bool
static Roslyn.Utilities.EnumerableExtensions.IsEmpty<T>(this System.Collections.Generic.ICollection<T> source) -> bool
static Roslyn.Utilities.EnumerableExtensions.IsEmpty<T>(this System.Collections.Generic.IEnumerable<T> source) -> bool
static Roslyn.Utilities.EnumerableExtensions.IsEmpty<T>(this System.Collections.Generic.IReadOnlyCollection<T> source) -> bool
static Roslyn.Utilities.EnumerableExtensions.IsEmpty<T>(this System.Collections.Generic.List<T> source) -> bool
static Roslyn.Utilities.EnumerableExtensions.IsEmpty<T>(this T[] source) -> bool
static Roslyn.Utilities.EnumerableExtensions.IsSingle<T>(this System.Collections.Generic.IEnumerable<T> list) -> bool
static Roslyn.Utilities.EnumerableExtensions.IsSorted<T>(this System.Collections.Generic.IEnumerable<T> enumerable, System.Collections.Generic.IComparer<T> comparer) -> bool
static Roslyn.Utilities.EnumerableExtensions.LastOrNullable<T>(this System.Collections.Generic.IEnumerable<T> source) -> T?
static Roslyn.Utilities.EnumerableExtensions.Order<T>(this System.Collections.Generic.IEnumerable<T> source) -> System.Linq.IOrderedEnumerable<T>
static Roslyn.Utilities.EnumerableExtensions.OrderBy<T>(this System.Collections.Generic.IEnumerable<T> source, System.Collections.Generic.IComparer<T> comparer) -> System.Linq.IOrderedEnumerable<T>
static Roslyn.Utilities.EnumerableExtensions.OrderBy<T>(this System.Collections.Generic.IEnumerable<T> source, System.Comparison<T> compare) -> System.Linq.IOrderedEnumerable<T>
static Roslyn.Utilities.EnumerableExtensions.SelectAsArray<TSource, TResult>(this System.Collections.Generic.IEnumerable<TSource> source, System.Func<TSource, TResult> selector) -> System.Collections.Immutable.ImmutableArray<TResult>
static Roslyn.Utilities.EnumerableExtensions.SetEquals<T>(this System.Collections.Generic.IEnumerable<T> source1, System.Collections.Generic.IEnumerable<T> source2) -> bool
static Roslyn.Utilities.EnumerableExtensions.SetEquals<T>(this System.Collections.Generic.IEnumerable<T> source1, System.Collections.Generic.IEnumerable<T> source2, System.Collections.Generic.IEqualityComparer<T> comparer) -> bool
static Roslyn.Utilities.EnumerableExtensions.ThenBy<T>(this System.Linq.IOrderedEnumerable<T> source) -> System.Linq.IOrderedEnumerable<T>
static Roslyn.Utilities.EnumerableExtensions.ThenBy<T>(this System.Linq.IOrderedEnumerable<T> source, System.Collections.Generic.IComparer<T> comparer) -> System.Linq.IOrderedEnumerable<T>
static Roslyn.Utilities.EnumerableExtensions.ThenBy<T>(this System.Linq.IOrderedEnumerable<T> source, System.Comparison<T> compare) -> System.Linq.IOrderedEnumerable<T>
static Roslyn.Utilities.EnumerableExtensions.ToComparer<T>(this System.Comparison<T> comparison) -> System.Collections.Generic.IComparer<T>
static Roslyn.Utilities.EnumerableExtensions.ToReadOnlyCollection<T>(this System.Collections.Generic.IEnumerable<T> source) -> System.Collections.ObjectModel.ReadOnlyCollection<T>
static Roslyn.Utilities.EnumerableExtensions.ToSet<T>(this System.Collections.Generic.IEnumerable<T> source) -> System.Collections.Generic.ISet<T>
static Roslyn.Utilities.EnumerableExtensions.ToSet<T>(this System.Collections.Generic.IEnumerable<T> source, System.Collections.Generic.IEqualityComparer<T> comparer) -> System.Collections.Generic.ISet<T>
static Roslyn.Utilities.EnumerableExtensions.WhereNotNull<T>(this System.Collections.Generic.IEnumerable<T> source) -> System.Collections.Generic.IEnumerable<T>
static Roslyn.Utilities.ExceptionUtilities.UnexpectedValue(object o) -> System.Exception
static Roslyn.Utilities.ExceptionUtilities.Unreachable.get -> System.Exception
static Roslyn.Utilities.FileNameUtilities.ChangeExtension(string path, string extension) -> string
static Roslyn.Utilities.FileNameUtilities.GetExtension(string path) -> string
static Roslyn.Utilities.FileNameUtilities.GetFileName(string path, bool includeExtension = true) -> string
static Roslyn.Utilities.FileNameUtilities.IndexOfFileName(string path) -> int
static Roslyn.Utilities.FileNameUtilities.IsFileName(string path) -> bool
static Roslyn.Utilities.FileUtilities.CreateFileStreamChecked(System.Func<string, System.IO.Stream> factory, string path, string paramName = null) -> System.IO.Stream
static Roslyn.Utilities.FileUtilities.GetFileLength(string fullPath) -> long
static Roslyn.Utilities.FileUtilities.GetFileTimeStamp(string fullPath) -> System.DateTime
static Roslyn.Utilities.FileUtilities.NormalizeAbsolutePath(string path) -> string
static Roslyn.Utilities.FileUtilities.NormalizeDirectoryPath(string path) -> string
static Roslyn.Utilities.FileUtilities.NormalizeRelativePath(string path, string basePath, string baseDirectory) -> string
static Roslyn.Utilities.FileUtilities.OpenAsyncRead(string fullPath) -> System.IO.Stream
static Roslyn.Utilities.FileUtilities.OpenFileStream(string path) -> System.IO.Stream
static Roslyn.Utilities.FileUtilities.OpenRead(string fullPath) -> System.IO.Stream
static Roslyn.Utilities.FileUtilities.ResolveRelativePath(string path, string baseDirectory) -> string
static Roslyn.Utilities.FileUtilities.ResolveRelativePath(string path, string basePath, string baseDirectory) -> string
static Roslyn.Utilities.FileUtilities.ResolveRelativePath(string path, string basePath, string baseDirectory, System.Collections.Generic.IEnumerable<string> searchPaths, System.Func<string, bool> fileExists) -> string
static Roslyn.Utilities.FileUtilities.RethrowExceptionsAsIOException<T>(System.Func<T> operation) -> T
static Roslyn.Utilities.FileUtilities.TryNormalizeAbsolutePath(string path) -> string
static Roslyn.Utilities.Hash.Combine(bool newKeyPart, int currentKey) -> int
static Roslyn.Utilities.Hash.Combine(int newKey, int currentKey) -> int
static Roslyn.Utilities.Hash.Combine<T>(T newKeyPart, int currentKey) -> int
static Roslyn.Utilities.Hash.CombineFNVHash(int hashCode, char ch) -> int
static Roslyn.Utilities.Hash.CombineFNVHash(int hashCode, string text) -> int
static Roslyn.Utilities.Hash.CombineValues(System.Collections.Generic.IEnumerable<string> values, System.StringComparer stringComparer, int maxItemsToHash = 2147483647) -> int
static Roslyn.Utilities.Hash.CombineValues<T>(System.Collections.Generic.IEnumerable<T> values, int maxItemsToHash = 2147483647) -> int
static Roslyn.Utilities.Hash.CombineValues<T>(System.Collections.Immutable.ImmutableArray<T> values, int maxItemsToHash = 2147483647) -> int
static Roslyn.Utilities.Hash.CombineValues<T>(T[] values, int maxItemsToHash = 2147483647) -> int
static Roslyn.Utilities.Hash.GetCaseInsensitiveFNVHashCode(string text) -> int
static Roslyn.Utilities.Hash.GetCaseInsensitiveFNVHashCode(string text, int start, int length) -> int
static Roslyn.Utilities.Hash.GetFNVHashCode(System.Collections.Immutable.ImmutableArray<byte> data) -> int
static Roslyn.Utilities.Hash.GetFNVHashCode(System.Text.StringBuilder text) -> int
static Roslyn.Utilities.Hash.GetFNVHashCode(byte* data, int length, out bool isAscii) -> int
static Roslyn.Utilities.Hash.GetFNVHashCode(byte[] data) -> int
static Roslyn.Utilities.Hash.GetFNVHashCode(char ch) -> int
static Roslyn.Utilities.Hash.GetFNVHashCode(char[] text, int start, int length) -> int
static Roslyn.Utilities.Hash.GetFNVHashCode(string text) -> int
static Roslyn.Utilities.Hash.GetFNVHashCode(string text, int start) -> int
static Roslyn.Utilities.Hash.GetFNVHashCode(string text, int start, int length) -> int
static Roslyn.Utilities.HexUtilities.ConvertHexDigit(char val) -> int
static Roslyn.Utilities.HexUtilities.DecodeHexString(string hexString) -> byte[]
static Roslyn.Utilities.HexUtilities.EncodeHexString(byte[] sArray) -> string
static Roslyn.Utilities.HexUtilities.EncodeHexStringFromInt(byte[] sArray) -> string
static Roslyn.Utilities.HexUtilities.HexDigit(int num) -> char
static Roslyn.Utilities.ISetExtensions.AddAll<T>(this System.Collections.Generic.ISet<T> set, System.Collections.Generic.IEnumerable<T> values) -> bool
static Roslyn.Utilities.ISetExtensions.RemoveAll<T>(this System.Collections.Generic.ISet<T> set, System.Collections.Generic.IEnumerable<T> values) -> bool
static Roslyn.Utilities.ImmutableArrayExtensions.BinarySearch<TElement, TValue>(this System.Collections.Immutable.ImmutableArray<TElement> array, TValue value, System.Func<TElement, TValue, int> comparer) -> int
static Roslyn.Utilities.ImmutableArrayExtensions.ToImmutableArrayOrEmpty<T>(this System.Collections.Generic.IEnumerable<T> items) -> System.Collections.Immutable.ImmutableArray<T>
static Roslyn.Utilities.ImmutableArrayExtensions.ToImmutableArrayOrEmpty<T>(this System.Collections.Immutable.ImmutableArray<T> items) -> System.Collections.Immutable.ImmutableArray<T>
static Roslyn.Utilities.ImmutableByteArrayInterop.DangerousCreateFromUnderlyingArray(ref byte[] array) -> System.Collections.Immutable.ImmutableArray<byte>
static Roslyn.Utilities.ImmutableByteArrayInterop.DangerousGetUnderlyingArray(this System.Collections.Immutable.ImmutableArray<byte> array) -> byte[]
static Roslyn.Utilities.ImmutableInt32ArrayInterop.DangerousCreateFromUnderlyingArray(ref int[] array) -> System.Collections.Immutable.ImmutableArray<int>
static Roslyn.Utilities.ImmutableInt32ArrayInterop.DangerousGetUnderlyingArray(this System.Collections.Immutable.ImmutableArray<int> array) -> int[]
static Roslyn.Utilities.ImmutableListExtensions.ToImmutableListOrEmpty<T>(this System.Collections.Generic.IEnumerable<T> items) -> System.Collections.Immutable.ImmutableList<T>
static Roslyn.Utilities.ImmutableListExtensions.ToImmutableListOrEmpty<T>(this T[] items) -> System.Collections.Immutable.ImmutableList<T>
static Roslyn.Utilities.InterlockedOperations.Initialize<T>(ref System.Collections.Immutable.ImmutableArray<T> target, System.Collections.Immutable.ImmutableArray<T> initializedValue) -> System.Collections.Immutable.ImmutableArray<T>
static Roslyn.Utilities.InterlockedOperations.Initialize<T>(ref T target, T initializedValue, T uninitializedValue) -> T
static Roslyn.Utilities.InterlockedOperations.Initialize<T>(ref T target, T value) -> T
static Roslyn.Utilities.ObjectBinder.GetSnapshot() -> Roslyn.Utilities.ObjectBinderSnapshot
static Roslyn.Utilities.ObjectBinder.RegisterTypeReader(System.Type type, System.Func<Roslyn.Utilities.ObjectReader, object> typeReader) -> void
static Roslyn.Utilities.ObjectReader.TryGetReader(System.IO.Stream stream, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> Roslyn.Utilities.ObjectReader
static Roslyn.Utilities.OneOrMany.Create<T>(System.Collections.Immutable.ImmutableArray<T> many) -> Roslyn.Utilities.OneOrMany<T>
static Roslyn.Utilities.OneOrMany.Create<T>(T one) -> Roslyn.Utilities.OneOrMany<T>
static Roslyn.Utilities.PathUtilities.ChangeExtension(string path, string extension) -> string
static Roslyn.Utilities.PathUtilities.CombineAbsoluteAndRelativePaths(string root, string relativePath) -> string
static Roslyn.Utilities.PathUtilities.CombinePathsUnchecked(string root, string relativePath) -> string
static Roslyn.Utilities.PathUtilities.CombinePossiblyRelativeAndRelativePaths(string rootOpt, string relativePath) -> string
static Roslyn.Utilities.PathUtilities.ContainsPathComponent(string path, string component, bool ignoreCase) -> bool
static Roslyn.Utilities.PathUtilities.EnsureTrailingSeparator(string s) -> string
static Roslyn.Utilities.PathUtilities.GetDirectoryName(string path) -> string
static Roslyn.Utilities.PathUtilities.GetDirectoryName(string path, bool isUnixLike) -> string
static Roslyn.Utilities.PathUtilities.GetExtension(string path) -> string
static Roslyn.Utilities.PathUtilities.GetFileName(string path, bool includeExtension = true) -> string
static Roslyn.Utilities.PathUtilities.GetPathKind(string path) -> Roslyn.Utilities.PathKind
static Roslyn.Utilities.PathUtilities.GetPathRoot(string path) -> string
static Roslyn.Utilities.PathUtilities.GetRelativePath(string directory, string fullPath) -> string
static Roslyn.Utilities.PathUtilities.IsAbsolute(string path) -> bool
static Roslyn.Utilities.PathUtilities.IsAnyDirectorySeparator(char c) -> bool
static Roslyn.Utilities.PathUtilities.IsChildPath(string parentPath, string childPath) -> bool
static Roslyn.Utilities.PathUtilities.IsDirectorySeparator(char c) -> bool
static Roslyn.Utilities.PathUtilities.IsFilePath(string assemblyDisplayNameOrPath) -> bool
static Roslyn.Utilities.PathUtilities.IsSameDirectoryOrChildOf(string child, string parent) -> bool
static Roslyn.Utilities.PathUtilities.IsUnixLikePlatform.get -> bool
static Roslyn.Utilities.PathUtilities.IsValidFilePath(string path) -> bool
static Roslyn.Utilities.PathUtilities.NormalizePathPrefix(string filePath, System.Collections.Immutable.ImmutableArray<System.Collections.Generic.KeyValuePair<string, string>> pathMap) -> string
static Roslyn.Utilities.PathUtilities.PathsEqual(string path1, string path2) -> bool
static Roslyn.Utilities.PathUtilities.RemoveExtension(string path) -> string
static Roslyn.Utilities.PathUtilities.TrimTrailingSeparators(string s) -> string
static Roslyn.Utilities.PlatformInformation.IsUnix.get -> bool
static Roslyn.Utilities.PlatformInformation.IsWindows.get -> bool
static Roslyn.Utilities.ReaderWriterLockSlimExtensions.AssertCanRead(this System.Threading.ReaderWriterLockSlim lock) -> void
static Roslyn.Utilities.ReaderWriterLockSlimExtensions.AssertCanWrite(this System.Threading.ReaderWriterLockSlim lock) -> void
static Roslyn.Utilities.ReaderWriterLockSlimExtensions.DisposableRead(this System.Threading.ReaderWriterLockSlim lock) -> Roslyn.Utilities.ReaderWriterLockSlimExtensions.ReadLockExiter
static Roslyn.Utilities.ReaderWriterLockSlimExtensions.DisposableWrite(this System.Threading.ReaderWriterLockSlim lock) -> Roslyn.Utilities.ReaderWriterLockSlimExtensions.WriteLockExiter
static Roslyn.Utilities.ReferenceEqualityComparer.GetHashCode(object a) -> int
static Roslyn.Utilities.ReflectionUtilities.CreateDelegate<T>(this System.Reflection.MethodInfo methodInfo) -> T
static Roslyn.Utilities.ReflectionUtilities.FindItem<T>(System.Collections.Generic.IEnumerable<T> collection, params System.Type[] paramTypes) -> T
static Roslyn.Utilities.ReflectionUtilities.GetDeclaredConstructor(this System.Reflection.TypeInfo typeInfo, params System.Type[] paramTypes) -> System.Reflection.ConstructorInfo
static Roslyn.Utilities.ReflectionUtilities.GetDeclaredMethod(this System.Reflection.TypeInfo typeInfo, string name, params System.Type[] paramTypes) -> System.Reflection.MethodInfo
static Roslyn.Utilities.ReflectionUtilities.GetTypeFromEither(ref System.Type lazyType, string contractName, string desktopName) -> System.Type
static Roslyn.Utilities.ReflectionUtilities.GetTypeFromEither(string contractName, string desktopName) -> System.Type
static Roslyn.Utilities.ReflectionUtilities.Invoke<T>(this System.Reflection.MethodInfo methodInfo, object obj, params object[] args) -> T
static Roslyn.Utilities.ReflectionUtilities.InvokeConstructor(this System.Reflection.ConstructorInfo constructorInfo, params object[] args) -> object
static Roslyn.Utilities.ReflectionUtilities.InvokeConstructor<T>(this System.Reflection.ConstructorInfo constructorInfo, params object[] args) -> T
static Roslyn.Utilities.ReflectionUtilities.TryGetType(ref System.Type lazyType, string assemblyQualifiedName) -> System.Type
static Roslyn.Utilities.ReflectionUtilities.TryGetType(string assemblyQualifiedName) -> System.Type
static Roslyn.Utilities.SemaphoreExtensions.DisposableWait(this System.Threading.Semaphore semaphore, System.Threading.CancellationToken cancellationToken) -> Roslyn.Utilities.SemaphoreExtensions.SemaphoreDisposer
static Roslyn.Utilities.SemaphoreExtensions.DisposableWaitAsync(this System.Threading.Semaphore semaphore, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<Roslyn.Utilities.SemaphoreExtensions.SemaphoreDisposer>
static Roslyn.Utilities.SemaphoreSlimExtensions.DisposableWait(this System.Threading.SemaphoreSlim semaphore, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> Roslyn.Utilities.SemaphoreSlimExtensions.SemaphoreDisposer
static Roslyn.Utilities.SemaphoreSlimExtensions.DisposableWaitAsync(this System.Threading.SemaphoreSlim semaphore, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<Roslyn.Utilities.SemaphoreSlimExtensions.SemaphoreDisposer>
static Roslyn.Utilities.SpecializedCollections.EmptyCollection<T>() -> System.Collections.Generic.ICollection<T>
static Roslyn.Utilities.SpecializedCollections.EmptyDictionary<TKey, TValue>() -> System.Collections.Generic.IDictionary<TKey, TValue>
static Roslyn.Utilities.SpecializedCollections.EmptyEnumerable<T>() -> System.Collections.Generic.IEnumerable<T>
static Roslyn.Utilities.SpecializedCollections.EmptyEnumerator<T>() -> System.Collections.Generic.IEnumerator<T>
static Roslyn.Utilities.SpecializedCollections.EmptyList<T>() -> System.Collections.Generic.IList<T>
static Roslyn.Utilities.SpecializedCollections.EmptyReadOnlyDictionary<TKey, TValue>() -> System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>
static Roslyn.Utilities.SpecializedCollections.EmptyReadOnlyList<T>() -> System.Collections.Generic.IReadOnlyList<T>
static Roslyn.Utilities.SpecializedCollections.EmptyReadOnlySet<T>() -> Roslyn.Utilities.IReadOnlySet<T>
static Roslyn.Utilities.SpecializedCollections.EmptySet<T>() -> System.Collections.Generic.ISet<T>
static Roslyn.Utilities.SpecializedCollections.ReadOnlyCollection<T>(System.Collections.Generic.ICollection<T> collection) -> System.Collections.Generic.ICollection<T>
static Roslyn.Utilities.SpecializedCollections.ReadOnlyEnumerable<T>(System.Collections.Generic.IEnumerable<T> values) -> System.Collections.Generic.IEnumerable<T>
static Roslyn.Utilities.SpecializedCollections.ReadOnlySet<T>(System.Collections.Generic.ISet<T> set) -> System.Collections.Generic.ISet<T>
static Roslyn.Utilities.SpecializedCollections.SingletonCollection<T>(T value) -> System.Collections.Generic.ICollection<T>
static Roslyn.Utilities.SpecializedCollections.SingletonEnumerable<T>(T value) -> System.Collections.Generic.IEnumerable<T>
static Roslyn.Utilities.SpecializedCollections.SingletonEnumerator<T>(T value) -> System.Collections.Generic.IEnumerator<T>
static Roslyn.Utilities.SpecializedCollections.SingletonList<T>(T value) -> System.Collections.Generic.IList<T>
static Roslyn.Utilities.SpecializedCollections.StronglyTypedReadOnlySet<T>(System.Collections.Generic.ISet<T> set) -> Roslyn.Utilities.IReadOnlySet<T>
static Roslyn.Utilities.StreamExtensions.ReadAllBytes(this System.IO.Stream stream) -> byte[]
static Roslyn.Utilities.StreamExtensions.TryReadAll(this System.IO.Stream stream, byte[] buffer, int offset, int count) -> int
static Roslyn.Utilities.StringExtensions.All(this string arg, System.Predicate<char> predicate) -> bool
static Roslyn.Utilities.StringExtensions.First(this string arg) -> char
static Roslyn.Utilities.StringExtensions.GetCaseInsensitivePrefixLength(this string string1, string string2) -> int
static Roslyn.Utilities.StringExtensions.GetNumeral(int number) -> string
static Roslyn.Utilities.StringExtensions.GetWithSingleAttributeSuffix(this string name, bool isCaseSensitive) -> string
static Roslyn.Utilities.StringExtensions.GetWithoutAttributeSuffix(this string name, bool isCaseSensitive) -> string
static Roslyn.Utilities.StringExtensions.IndexOfBalancedParenthesis(this string str, int openingOffset, char closing) -> int
static Roslyn.Utilities.StringExtensions.IsValidClrNamespaceName(this string name) -> bool
static Roslyn.Utilities.StringExtensions.IsValidClrTypeName(this string name) -> bool
static Roslyn.Utilities.StringExtensions.IsValidUnicodeString(this string str) -> bool
static Roslyn.Utilities.StringExtensions.Join(this System.Collections.Generic.IEnumerable<string> source, string separator) -> string
static Roslyn.Utilities.StringExtensions.Last(this string arg) -> char
static Roslyn.Utilities.StringExtensions.LooksLikeInterfaceName(this string name) -> bool
static Roslyn.Utilities.StringExtensions.LooksLikeTypeParameterName(this string name) -> bool
static Roslyn.Utilities.StringExtensions.ToCamelCase(this string shortName, bool trimLeadingTypePrefix = true) -> string
static Roslyn.Utilities.StringExtensions.ToPascalCase(this string shortName, bool trimLeadingTypePrefix = true) -> string
static Roslyn.Utilities.StringExtensions.TryGetWithoutAttributeSuffix(this string name, bool isCaseSensitive, out string result) -> bool
static Roslyn.Utilities.StringExtensions.TryGetWithoutAttributeSuffix(this string name, out string result) -> bool
static Roslyn.Utilities.StringExtensions.Unquote(this string arg) -> string
static Roslyn.Utilities.StringExtensions.Unquote(this string arg, out bool quoted) -> string
static Roslyn.Utilities.StringOrdinalComparer.Equals(string a, string b) -> bool
static Roslyn.Utilities.StringTable.AddShared(System.Text.StringBuilder chars) -> string
static Roslyn.Utilities.StringTable.AddSharedUTF8(byte* bytes, int byteCount) -> string
static Roslyn.Utilities.StringTable.GetInstance() -> Roslyn.Utilities.StringTable
static Roslyn.Utilities.StringTable.TextEquals(string array, System.Text.StringBuilder text) -> bool
static Roslyn.Utilities.StringTable.TextEquals(string array, char[] text, int start, int length) -> bool
static Roslyn.Utilities.StringTable.TextEquals(string array, string text, int start, int length) -> bool
static Roslyn.Utilities.StringTable.TextEqualsASCII(string text, byte* ascii, int length) -> bool
static Roslyn.Utilities.TextChangeRangeExtensions.Accumulate(this Microsoft.CodeAnalysis.Text.TextChangeRange? accumulatedTextChangeSoFar, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Text.TextChangeRange> changesInNextVersion) -> Microsoft.CodeAnalysis.Text.TextChangeRange?
static Roslyn.Utilities.TextKeyedCache<T>.GetInstance() -> Roslyn.Utilities.TextKeyedCache<T>
static Roslyn.Utilities.ThreadSafeFlagOperations.Clear(ref int flags, int toClear) -> bool
static Roslyn.Utilities.ThreadSafeFlagOperations.Set(ref int flags, int toSet) -> bool
static Roslyn.Utilities.UICultureUtilities.WithCurrentUICulture(System.Action action) -> System.Action
static Roslyn.Utilities.UICultureUtilities.WithCurrentUICulture<T>(System.Action<T> action) -> System.Action<T>
static Roslyn.Utilities.UICultureUtilities.WithCurrentUICulture<T>(System.Func<T> func) -> System.Func<T>
static Roslyn.Utilities.UnicodeCharacterUtilities.IsFormattingChar(char ch) -> bool
static Roslyn.Utilities.UnicodeCharacterUtilities.IsIdentifierPartCharacter(char ch) -> bool
static Roslyn.Utilities.UnicodeCharacterUtilities.IsIdentifierStartCharacter(char ch) -> bool
static Roslyn.Utilities.UnicodeCharacterUtilities.IsValidIdentifier(string name) -> bool
static Roslyn.Utilities.WeakReferenceExtensions.GetTarget<T>(this System.WeakReference<T> reference) -> T
static Roslyn.Utilities.WeakReferenceExtensions.IsNull<T>(this System.WeakReference<T> reference) -> bool
static System.Linq.EnumerableExtensions.SequenceEqual<T>(this System.Collections.Generic.IEnumerable<T> first, System.Collections.Generic.IEnumerable<T> second, System.Func<T, T, bool> comparer) -> bool
static readonly Microsoft.CodeAnalysis.Boxes.BoxedByteZero -> object
static readonly Microsoft.CodeAnalysis.Boxes.BoxedDecimalZero -> object
static readonly Microsoft.CodeAnalysis.Boxes.BoxedDoubleZero -> object
static readonly Microsoft.CodeAnalysis.Boxes.BoxedFalse -> object
static readonly Microsoft.CodeAnalysis.Boxes.BoxedInt16Zero -> object
static readonly Microsoft.CodeAnalysis.Boxes.BoxedInt32One -> object
static readonly Microsoft.CodeAnalysis.Boxes.BoxedInt32Zero -> object
static readonly Microsoft.CodeAnalysis.Boxes.BoxedInt64Zero -> object
static readonly Microsoft.CodeAnalysis.Boxes.BoxedSByteZero -> object
static readonly Microsoft.CodeAnalysis.Boxes.BoxedSingleZero -> object
static readonly Microsoft.CodeAnalysis.Boxes.BoxedTrue -> object
static readonly Microsoft.CodeAnalysis.Boxes.BoxedUInt16Zero -> object
static readonly Microsoft.CodeAnalysis.Boxes.BoxedUInt32Zero -> object
static readonly Microsoft.CodeAnalysis.Boxes.BoxedUInt64Zero -> object
static readonly Microsoft.CodeAnalysis.NoLocation.Singleton -> Microsoft.CodeAnalysis.Location
static readonly Microsoft.CodeAnalysis.SmallDictionary<K, V>.Empty -> Microsoft.CodeAnalysis.SmallDictionary<K, V>
static readonly Roslyn.Utilities.ConsList<T>.Empty -> Roslyn.Utilities.ConsList<T>
static readonly Roslyn.Utilities.EmptyComparer.Instance -> Roslyn.Utilities.EmptyComparer
static readonly Roslyn.Utilities.Functions<T>.Identity -> System.Func<T, T>
static readonly Roslyn.Utilities.Functions<T>.True -> System.Func<T, bool>
static readonly Roslyn.Utilities.ImmutableSetWithInsertionOrder<T>.Empty -> Roslyn.Utilities.ImmutableSetWithInsertionOrder<T>
static readonly Roslyn.Utilities.PathUtilities.Comparer -> System.Collections.Generic.IEqualityComparer<string>
static readonly Roslyn.Utilities.ReferenceEqualityComparer.Instance -> Roslyn.Utilities.ReferenceEqualityComparer
static readonly Roslyn.Utilities.StringOrdinalComparer.Instance -> Roslyn.Utilities.StringOrdinalComparer
virtual Microsoft.CodeAnalysis.Diagnostic.DefaultSeverity.get -> Microsoft.CodeAnalysis.DiagnosticSeverity
virtual Microsoft.CodeAnalysis.Diagnostic.Properties.get -> System.Collections.Immutable.ImmutableDictionary<string, string>
virtual Microsoft.CodeAnalysis.DiagnosticFormatter.Format(Microsoft.CodeAnalysis.Diagnostic diagnostic, System.IFormatProvider formatter = null) -> string
virtual Microsoft.CodeAnalysis.DiagnosticFormatter.FormatSourcePath(string path, string basePath, System.IFormatProvider formatter) -> string
virtual Microsoft.CodeAnalysis.DiagnosticFormatter.FormatSourceSpan(Microsoft.CodeAnalysis.Text.LinePositionSpan span, System.IFormatProvider formatter) -> string
virtual Microsoft.CodeAnalysis.DiagnosticInfo.AdditionalLocations.get -> System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.Location>
virtual Microsoft.CodeAnalysis.DiagnosticInfo.GetMessage(System.IFormatProvider formatProvider = null) -> string
virtual Microsoft.CodeAnalysis.DiagnosticInfo.GetResolvedInfo() -> Microsoft.CodeAnalysis.DiagnosticInfo
virtual Microsoft.CodeAnalysis.DiagnosticInfo.WriteTo(Roslyn.Utilities.ObjectWriter writer) -> void
virtual Microsoft.CodeAnalysis.Location.GetLineSpan() -> Microsoft.CodeAnalysis.FileLinePositionSpan
virtual Microsoft.CodeAnalysis.Location.GetMappedLineSpan() -> Microsoft.CodeAnalysis.FileLinePositionSpan
virtual Microsoft.CodeAnalysis.Location.SourceSpan.get -> Microsoft.CodeAnalysis.Text.TextSpan
virtual Microsoft.CodeAnalysis.RelativePathResolver.FileExists(string fullPath) -> bool
virtual Microsoft.CodeAnalysis.Text.SourceText.Container.get -> Microsoft.CodeAnalysis.Text.SourceTextContainer
virtual Microsoft.CodeAnalysis.Text.SourceText.ContentEqualsImpl(Microsoft.CodeAnalysis.Text.SourceText other) -> bool
virtual Microsoft.CodeAnalysis.Text.SourceText.GetChangeRanges(Microsoft.CodeAnalysis.Text.SourceText oldText) -> System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.Text.TextChangeRange>
virtual Microsoft.CodeAnalysis.Text.SourceText.GetLinesCore() -> Microsoft.CodeAnalysis.Text.TextLineCollection
virtual Microsoft.CodeAnalysis.Text.SourceText.GetSubText(Microsoft.CodeAnalysis.Text.TextSpan span) -> Microsoft.CodeAnalysis.Text.SourceText
virtual Microsoft.CodeAnalysis.Text.SourceText.GetTextChanges(Microsoft.CodeAnalysis.Text.SourceText oldText) -> System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.Text.TextChange>
virtual Microsoft.CodeAnalysis.Text.SourceText.ToString(Microsoft.CodeAnalysis.Text.TextSpan span) -> string
virtual Microsoft.CodeAnalysis.Text.SourceText.WithChanges(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Text.TextChange> changes) -> Microsoft.CodeAnalysis.Text.SourceText
virtual Microsoft.CodeAnalysis.Text.SourceText.Write(System.IO.TextWriter writer, Microsoft.CodeAnalysis.Text.TextSpan span, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> void
virtual Microsoft.CodeAnalysis.Text.TextLineCollection.GetLineFromPosition(int position) -> Microsoft.CodeAnalysis.Text.TextLine
virtual Microsoft.CodeAnalysis.Text.TextLineCollection.GetLinePosition(int position) -> Microsoft.CodeAnalysis.Text.LinePosition
